/**
 * VulnerabilityEvaluator
 * 脆弱性評価システム
 * 
 * SOLID原則: 単一責任の原則 - 脆弱性評価に特化
 * DRY原則: 共通ロジックの一元化
 * Defensive Programming: 入力検証とエラーハンドリング
 */

import { CoreTypes, TypeGuards, TypeUtils } from '../../core/types/core-definitions';
import { RiskLevel } from '../types/unified-analysis-result';
import { 
  Vulnerability,
  SeverityLevel,
  ExploitabilityLevel,
  DetectabilityLevel
} from '../types/nist-types';

/**
 * 脆弱性評価結果
 */
export interface VulnerabilityAssessment {
  /** リスクレベル */
  riskLevel: RiskLevel;
  /** 悪用可能性の確率（0-1） */
  exploitProbability: number;
  /** 総合スコア（0-100） */
  overallScore: number;
  /** 評価の詳細説明 */
  description?: string;
}

/**
 * 複合脆弱性評価結果
 */
export interface CombinedVulnerabilityAssessment {
  /** 総合リスクレベル */
  overallRiskLevel: RiskLevel;
  /** 脆弱性の総数 */
  vulnerabilityCount: number;
  /** クリティカルレベルの脆弱性数 */
  criticalCount: number;
  /** 高レベルの脆弱性数 */
  highCount: number;
  /** 中レベルの脆弱性数 */
  mediumCount: number;
  /** 低レベルの脆弱性数 */
  lowCount: number;
  /** 最小レベルの脆弱性数 */
  minimalCount: number;
}

/**
 * 脆弱性チェーン
 */
export interface VulnerabilityChain {
  /** チェーンID */
  chainId: string;
  /** チェーンを構成する脆弱性ID */
  vulnerabilityIds: string[];
  /** 連鎖的リスクレベル */
  chainedRisk: RiskLevel;
  /** チェーンの説明 */
  description: string;
  /** 攻撃シナリオ */
  attackScenario?: string;
}

/**
 * 脆弱性に対する推奨事項
 */
export interface VulnerabilityRecommendation {
  /** 優先度 */
  priority: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  /** 推奨アクション */
  action: string;
  /** 実施タイムライン */
  timeline: string;
  /** 技術的詳細 */
  technicalDetails?: string;
  /** 参考リンク */
  references?: string[];
}

/**
 * 脆弱性評価器
 */
export class VulnerabilityEvaluator {
  /**
   * CVSSスコアをSeverityLevelに変換
   */
  cvssToSeverity(cvssScore: number): SeverityLevel {
    // 入力検証
    if (cvssScore < 0 || cvssScore > 10) {
      throw new Error('Invalid CVSS score: must be between 0 and 10');
    }

    // CVSS v3.1基準（正確な範囲）
    if (cvssScore >= 9.0) return 'CRITICAL';
    if (cvssScore >= 7.0) return 'HIGH';
    if (cvssScore >= 4.0) return 'MODERATE';
    if (cvssScore >= 1.0) return 'LOW';
    return 'VERY_LOW';
  }

  /**
   * CVSSスコアをRiskLevelに変換
   */
  cvssToRiskLevel(cvssScore: number): RiskLevel {
    // 入力検証
    if (cvssScore < 0 || cvssScore > 10) {
      throw new Error('Invalid CVSS score: must be between 0 and 10');
    }

    // CVSS v3.1基準（正確な範囲）
    if (cvssScore >= 9.0) return CoreTypes.RiskLevel.CRITICAL;
    if (cvssScore >= 7.0) return CoreTypes.RiskLevel.HIGH;
    if (cvssScore >= 4.0) return CoreTypes.RiskLevel.MEDIUM;
    if (cvssScore >= 1.0) return CoreTypes.RiskLevel.LOW;
    return CoreTypes.RiskLevel.MINIMAL;
  }

  /**
   * 単一の脆弱性を評価
   */
  assessVulnerability(vulnerability: Vulnerability): VulnerabilityAssessment {
    // 入力検証
    if (!vulnerability) {
      throw new Error('Vulnerability is required');
    }

    // データ検証
    if (!vulnerability.severity || !vulnerability.exploitability || !vulnerability.detectability) {
      throw new Error('Invalid vulnerability data: missing required fields');
    }

    // 悪用可能性の計算
    const exploitProbability = this.calculateExploitProbability(
      vulnerability.exploitability,
      vulnerability.detectability
    );

    // リスクレベルの決定
    const riskLevel = this.determineRiskLevel(vulnerability);

    // 総合スコアの計算
    const overallScore = this.calculateOverallScore(vulnerability, exploitProbability);

    return {
      riskLevel,
      exploitProbability,
      overallScore,
      description: this.generateAssessmentDescription(vulnerability, riskLevel)
    };
  }

  /**
   * 複数の脆弱性を総合評価
   */
  assessCombinedVulnerabilities(vulnerabilities: Vulnerability[]): CombinedVulnerabilityAssessment {
    // 空のリストの処理
    if (!vulnerabilities || vulnerabilities.length === 0) {
      return {
        overallRiskLevel: CoreTypes.RiskLevel.MINIMAL,
        vulnerabilityCount: 0,
        criticalCount: 0,
        highCount: 0,
        mediumCount: 0,
        lowCount: 0,
        minimalCount: 0
      };
    }

    // 各脆弱性を評価してカウント
    const counts = {
      criticalCount: 0,
      highCount: 0,
      mediumCount: 0,
      lowCount: 0,
      minimalCount: 0
    };

    let highestRisk = CoreTypes.RiskLevel.MINIMAL;

    for (const vuln of vulnerabilities) {
      const assessment = this.assessVulnerability(vuln);
      
      // リスクレベル別にカウント
      switch (assessment.riskLevel) {
        case CoreTypes.RiskLevel.CRITICAL:
          counts.criticalCount++;
          break;
        case CoreTypes.RiskLevel.HIGH:
          counts.highCount++;
          break;
        case CoreTypes.RiskLevel.MEDIUM:
          counts.mediumCount++;
          break;
        case CoreTypes.RiskLevel.LOW:
          counts.lowCount++;
          break;
        case CoreTypes.RiskLevel.MINIMAL:
          counts.minimalCount++;
          break;
      }

      // 最高リスクレベルを更新
      if (this.getRiskPriority(assessment.riskLevel) > this.getRiskPriority(highestRisk)) {
        highestRisk = assessment.riskLevel;
      }
    }

    return {
      overallRiskLevel: highestRisk,
      vulnerabilityCount: vulnerabilities.length,
      ...counts
    };
  }

  /**
   * 脆弱性チェーンを検出
   */
  detectVulnerabilityChains(vulnerabilities: Vulnerability[]): VulnerabilityChain[] {
    const chains: VulnerabilityChain[] = [];

    // 入力検証と出力サニタイズの組み合わせを検出
    const inputVulns = vulnerabilities.filter(v => 
      v.description.toLowerCase().includes('入力') || 
      v.description.toLowerCase().includes('input')
    );
    
    const injectionVulns = vulnerabilities.filter(v =>
      v.description.toLowerCase().includes('injection') ||
      v.description.toLowerCase().includes('インジェクション')
    );

    if (inputVulns.length > 0 && injectionVulns.length > 0) {
      chains.push({
        chainId: 'CHAIN-001',
        vulnerabilityIds: [...inputVulns.map(v => v.id), ...injectionVulns.map(v => v.id)],
        chainedRisk: CoreTypes.RiskLevel.CRITICAL,
        description: '連鎖的な脆弱性: 入力検証不足とインジェクション攻撃の組み合わせ',
        attackScenario: '攻撃者は入力検証の不備を利用して、インジェクション攻撃を実行する可能性があります'
      });
    }

    return chains;
  }

  /**
   * リスクレベルに基づいて脆弱性を優先順位付け
   */
  prioritizeVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
    return [...vulnerabilities].sort((a, b) => {
      const assessA = this.assessVulnerability(a);
      const assessB = this.assessVulnerability(b);
      
      // リスクレベルで比較
      const priorityDiff = this.getRiskPriority(assessB.riskLevel) - this.getRiskPriority(assessA.riskLevel);
      if (priorityDiff !== 0) return priorityDiff;
      
      // 同じリスクレベルの場合は悪用可能性で比較
      return assessB.exploitProbability - assessA.exploitProbability;
    });
  }

  /**
   * 悪用可能性の高い脆弱性を識別
   */
  getHighlyExploitableVulnerabilities(vulnerabilities: Vulnerability[], threshold: number = 0.7): Vulnerability[] {
    return vulnerabilities.filter(vuln => {
      const exploitProbability = this.calculateExploitProbability(
        vuln.exploitability,
        vuln.detectability
      );
      return exploitProbability >= threshold;
    });
  }

  /**
   * 脆弱性に対する推奨事項を生成
   */
  generateRecommendations(vulnerability: Vulnerability): VulnerabilityRecommendation[] {
    const recommendations: VulnerabilityRecommendation[] = [];
    const assessment = this.assessVulnerability(vulnerability);

    // 脆弱性タイプに応じた推奨事項
    if (vulnerability.description.toLowerCase().includes('sql') || 
        vulnerability.description.toLowerCase().includes('injection')) {
      recommendations.push({
        priority: assessment.riskLevel === CoreTypes.RiskLevel.CRITICAL ? 'CRITICAL' : 'HIGH',
        action: 'パラメータ化クエリまたはプリペアドステートメントを使用してSQLインジェクションを防止',
        timeline: assessment.riskLevel === CoreTypes.RiskLevel.CRITICAL ? '直ちに（24時間以内）' : '1週間以内',
        technicalDetails: 'すべてのデータベースクエリをパラメータ化し、ユーザー入力を直接SQLに組み込まないように修正',
        references: ['OWASP SQL Injection Prevention Cheat Sheet']
      });
    }

    if (vulnerability.description.toLowerCase().includes('xss')) {
      recommendations.push({
        priority: assessment.riskLevel === CoreTypes.RiskLevel.CRITICAL ? 'CRITICAL' : 'HIGH',
        action: '出力エスケープとコンテンツセキュリティポリシー（CSP）の実装によりXSSを防止',
        timeline: assessment.riskLevel === CoreTypes.RiskLevel.CRITICAL ? '48時間以内' : '1週間以内',
        technicalDetails: 'HTMLコンテキストに応じた適切なエスケープまたはサニタイズ処理を実装',
        references: ['OWASP XSS Prevention Cheat Sheet']
      });
    }

    // CVE情報がある場合の推奨事項
    if (vulnerability.cveId) {
      recommendations.push({
        priority: 'HIGH',
        action: `${vulnerability.cveId}に対する公式パッチまたは回避策を適用`,
        timeline: '可能な限り早急に',
        references: [`https://cve.mitre.org/cgi-bin/cvename.cgi?name=${vulnerability.cveId}`]
      });
    }

    // 一般的な推奨事項
    if (recommendations.length === 0) {
      recommendations.push({
        priority: this.severityToPriority(vulnerability.severity),
        action: '脆弱性の根本原因を特定し、適切な修正を実施',
        timeline: this.getTimelineForSeverity(vulnerability.severity)
      });
    }

    return recommendations;
  }

  // ========== Private Helper Methods ==========

  private calculateExploitProbability(
    exploitability: ExploitabilityLevel,
    detectability: DetectabilityLevel
  ): number {
    const exploitScores: Record<ExploitabilityLevel, number> = {
      'VERY_LOW': 0.1,
      'LOW': 0.3,
      'MODERATE': 0.5,
      'HIGH': 0.7,
      'VERY_HIGH': 0.9
    };

    const detectScores: Record<DetectabilityLevel, number> = {
      'VERY_HARD': 0.1,
      'HARD': 0.3,
      'MODERATE': 0.5,
      'EASY': 0.7,
      'VERY_EASY': 0.9
    };

    const exploitScore = exploitScores[exploitability] || 0.5;
    const detectScore = detectScores[detectability] || 0.5;

    // 悪用可能性 = (悪用容易性 × 0.6) + (検出容易性 × 0.4)
    return (exploitScore * 0.6) + (detectScore * 0.4);
  }

  private determineRiskLevel(vulnerability: Vulnerability): RiskLevel {
    // CVSSスコアがある場合はそれを優先
    if (vulnerability.cvssScore !== undefined) {
      return this.cvssToRiskLevel(vulnerability.cvssScore);
    }

    // Severityをベースにリスクレベルを決定
    const severityMapping: Record<SeverityLevel, RiskLevel> = {
      'CRITICAL': CoreTypes.RiskLevel.CRITICAL,
      'VERY_HIGH': CoreTypes.RiskLevel.HIGH,
      'HIGH': CoreTypes.RiskLevel.HIGH,
      'MODERATE': CoreTypes.RiskLevel.MEDIUM,
      'LOW': CoreTypes.RiskLevel.LOW,
      'VERY_LOW': CoreTypes.RiskLevel.MINIMAL
    };

    return severityMapping[vulnerability.severity] || CoreTypes.RiskLevel.MEDIUM;
  }

  private calculateOverallScore(vulnerability: Vulnerability, exploitProbability: number): number {
    // 基本スコア（Severityベース）
    const severityScores: Record<SeverityLevel, number> = {
      'CRITICAL': 100,
      'VERY_HIGH': 85,
      'HIGH': 70,
      'MODERATE': 50,
      'LOW': 30,
      'VERY_LOW': 10
    };

    const baseScore = severityScores[vulnerability.severity] || 50;

    // 悪用可能性による調整（±20点）
    const exploitAdjustment = (exploitProbability - 0.5) * 40;

    // 影響範囲による調整（最大+10点）
    const assetImpact = vulnerability.affectedAssets 
      ? Math.min(vulnerability.affectedAssets.length * 2, 10)
      : 0;

    return Math.max(0, Math.min(100, baseScore + exploitAdjustment + assetImpact));
  }

  private generateAssessmentDescription(vulnerability: Vulnerability, riskLevel: RiskLevel): string {
    const riskDescriptions: Record<RiskLevel, string> = {
      [CoreTypes.RiskLevel.CRITICAL]: '緊急対応が必要な重大な脆弱性',
      [CoreTypes.RiskLevel.HIGH]: '早急な対応が必要な高リスク脆弱性',
      [CoreTypes.RiskLevel.MEDIUM]: '計画的な対応が必要な中程度のリスク',
      [CoreTypes.RiskLevel.LOW]: '監視と定期的な見直しが必要な低リスク',
      [CoreTypes.RiskLevel.MINIMAL]: '最小限のリスク、継続的な監視を推奨'
    };

    return `${riskDescriptions[riskLevel]}。${vulnerability.description}`;
  }

  private getRiskPriority(riskLevel: RiskLevel): number {
    const priorities: Record<RiskLevel, number> = {
      [CoreTypes.RiskLevel.CRITICAL]: 5,
      [CoreTypes.RiskLevel.HIGH]: 4,
      [CoreTypes.RiskLevel.MEDIUM]: 3,
      [CoreTypes.RiskLevel.LOW]: 2,
      [CoreTypes.RiskLevel.MINIMAL]: 1
    };
    return priorities[riskLevel] || 0;
  }

  private severityToPriority(severity: SeverityLevel): 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' {
    if (severity === 'CRITICAL' || severity === 'VERY_HIGH') return 'CRITICAL';
    if (severity === 'HIGH') return 'HIGH';
    if (severity === 'MODERATE') return 'MEDIUM';
    return 'LOW';
  }

  private getTimelineForSeverity(severity: SeverityLevel): string {
    const timelines: Record<SeverityLevel, string> = {
      'CRITICAL': '直ちに（24時間以内）',
      'VERY_HIGH': '48時間以内',
      'HIGH': '1週間以内',
      'MODERATE': '2週間以内',
      'LOW': '1ヶ月以内',
      'VERY_LOW': '次回の定期メンテナンス時'
    };
    return timelines[severity] || '適切なタイミングで';
  }
}