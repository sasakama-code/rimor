/**
 * TaintVulnerabilityAdapter
 * TaintAnalysisとVulnerabilityEvaluatorを統合するアダプター
 * 
 * SOLID原則: アダプターパターンでインターフェース分離
 * DRY原則: 変換ロジックの一元化
 * Defensive Programming: 入力検証とエラーハンドリング
 */

import { VulnerabilityEvaluator } from '../evaluators/VulnerabilityEvaluator';
import { RiskLevel } from '../types/unified-analysis-result';
import {
  Vulnerability,
  SeverityLevel,
  ExploitabilityLevel,
  DetectabilityLevel
} from '../types/nist-types';
import {
  TaintAnalysisResult,
  TaintLevel,
  TaintFlow,
  TaintChainRisk,
  TaintVulnerabilityAssessment
} from '../../security/types/taint-analysis-types';

/**
 * 脆弱性推奨事項
 */
export interface VulnerabilityRecommendation {
  priority: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  action: string;
  timeline: string;
  technicalDetails?: string;
  references?: string[];
}

/**
 * 複合脆弱性評価結果
 */
export interface CombinedVulnerabilityAssessment {
  overallRiskLevel: RiskLevel;
  vulnerabilityCount: number;
  criticalCount: number;
  highCount: number;
  mediumCount: number;
  lowCount: number;
  minimalCount: number;
  recommendations?: VulnerabilityRecommendation[];
}

/**
 * 脆弱性チェーン
 */
export interface VulnerabilityChain {
  chainId: string;
  vulnerabilityIds: string[];
  chainedRisk: RiskLevel;
  description: string;
  attackScenario?: string;
}

/**
 * TaintAnalysisとVulnerabilityEvaluatorを統合するアダプター
 */
export class TaintVulnerabilityAdapter {
  constructor(private vulnerabilityEvaluator: VulnerabilityEvaluator) {}

  /**
   * Taint解析結果を脆弱性に変換
   */
  convertTaintToVulnerabilities(taintResult: TaintAnalysisResult): Vulnerability[] {
    return taintResult.flows.map(flow => this.convertFlowToVulnerability(flow));
  }

  /**
   * 単一のTaintフローを脆弱性に変換
   */
  private convertFlowToVulnerability(flow: TaintFlow): Vulnerability {
    const severity = this.mapTaintLevelToSeverity(flow.taintLevel);
    const exploitability = this.mapConfidenceToExploitability(flow.confidence);
    const detectability = this.mapConfidenceToDetectability(flow.confidence);
    const cvss = this.calculateCVSSFromTaint(flow);

    return {
      id: flow.id,
      type: 'TAINT_FLOW',
      severity,
      exploitability,
      detectability,
      description: flow.description,
      affectedComponent: `${flow.sinkLocation.file}:${flow.sinkLocation.line}`,
      cvss,
      cweId: flow.cweId,
      attackVector: flow.attackVector
    };
  }

  /**
   * TaintLevelをSeverityLevelにマッピング
   */
  mapTaintLevelToSeverity(taintLevel: TaintLevel): SeverityLevel {
    if (!Object.values(TaintLevel).includes(taintLevel)) {
      throw new Error('Invalid taint level');
    }

    switch (taintLevel) {
      case TaintLevel.CRITICAL:
        return 'CRITICAL';
      case TaintLevel.HIGH:
        return 'HIGH';
      case TaintLevel.MEDIUM:
        return 'MODERATE';
      case TaintLevel.LOW:
        return 'LOW';
      case TaintLevel.SAFE:
        return 'VERY_LOW';
      default:
        return 'MODERATE';
    }
  }

  /**
   * 信頼度をExploitabilityLevelにマッピング
   */
  private mapConfidenceToExploitability(confidence: number): ExploitabilityLevel {
    if (confidence >= 0.9) return 'VERY_HIGH';
    if (confidence >= 0.7) return 'HIGH';
    if (confidence >= 0.5) return 'MODERATE';
    if (confidence >= 0.3) return 'LOW';
    return 'VERY_LOW';
  }

  /**
   * 信頼度をDetectabilityLevelにマッピング
   */
  mapConfidenceToDetectability(confidence: number): DetectabilityLevel {
    const clampedConfidence = Math.max(0, Math.min(1, confidence));
    
    if (clampedConfidence >= 0.8) return 'VERY_EASY';
    if (clampedConfidence >= 0.6) return 'EASY';
    if (clampedConfidence >= 0.4) return 'MODERATE';
    if (clampedConfidence >= 0.2) return 'HARD';
    return 'VERY_HARD';
  }

  /**
   * TaintフローからCVSSスコアを計算
   */
  private calculateCVSSFromTaint(flow: TaintFlow): number {
    const baseSeverity = this.taintLevelToCVSSBase(flow.taintLevel);
    const confidenceMultiplier = flow.confidence;
    
    return Math.min(10, baseSeverity * confidenceMultiplier);
  }

  /**
   * TaintLevelをCVSS基本スコアに変換
   */
  private taintLevelToCVSSBase(taintLevel: TaintLevel): number {
    const scores: Record<TaintLevel, number> = {
      [TaintLevel.CRITICAL]: 10,
      [TaintLevel.HIGH]: 8.5,
      [TaintLevel.MEDIUM]: 6.5,
      [TaintLevel.LOW]: 4,
      [TaintLevel.SAFE]: 0
    };
    return scores[taintLevel];
  }

  /**
   * Taint脆弱性を評価
   */
  async evaluateTaintVulnerabilities(taintResult: TaintAnalysisResult): Promise<CombinedVulnerabilityAssessment> {
    const vulnerabilities = this.convertTaintToVulnerabilities(taintResult);
    
    const criticalCount = vulnerabilities.filter(v => v.severity === 'CRITICAL').length;
    const highCount = vulnerabilities.filter(v => v.severity === 'HIGH').length;
    const mediumCount = vulnerabilities.filter(v => v.severity === 'MODERATE').length;
    const lowCount = vulnerabilities.filter(v => v.severity === 'LOW').length;
    const minimalCount = vulnerabilities.filter(v => v.severity === 'VERY_LOW').length;

    const overallRiskLevel = this.determineOverallRiskLevel(vulnerabilities);
    const recommendations = this.generateRecommendations(vulnerabilities);

    return {
      overallRiskLevel,
      vulnerabilityCount: vulnerabilities.length,
      criticalCount,
      highCount,
      mediumCount,
      lowCount,
      minimalCount,
      recommendations
    };
  }

  /**
   * 全体的なリスクレベルを決定
   */
  private determineOverallRiskLevel(vulnerabilities: Vulnerability[]): RiskLevel {
    if (vulnerabilities.length === 0) return RiskLevel.MINIMAL;
    
    const severities = vulnerabilities.map(v => v.severity);
    
    if (severities.includes('CRITICAL')) return RiskLevel.CRITICAL;
    if (severities.includes('HIGH')) return RiskLevel.HIGH;
    if (severities.includes('MODERATE')) return RiskLevel.MEDIUM;
    if (severities.includes('LOW')) return RiskLevel.LOW;
    
    return RiskLevel.MINIMAL;
  }

  /**
   * 連鎖リスクを検出
   */
  async detectChainedRisks(taintResult: TaintAnalysisResult): Promise<VulnerabilityChain[]> {
    const chains: VulnerabilityChain[] = [];
    const flows = taintResult.flows;

    for (let i = 0; i < flows.length; i++) {
      for (let j = i + 1; j < flows.length; j++) {
        if (this.areFlowsChained(flows[i], flows[j])) {
          const chainedRisk = this.calculateChainedRisk(flows[i], flows[j]);
          chains.push({
            chainId: `CHAIN-${flows[i].id}-${flows[j].id}`,
            vulnerabilityIds: [flows[i].id, flows[j].id],
            chainedRisk,
            description: `連鎖的な脆弱性: ${flows[i].description} → ${flows[j].description}`,
            attackScenario: this.generateAttackScenario(flows[i], flows[j])
          });
        }
      }
    }

    return chains;
  }

  /**
   * フローが連鎖しているか判定
   */
  private areFlowsChained(flow1: TaintFlow, flow2: TaintFlow): boolean {
    return flow1.sinkLocation.file === flow2.sourceLocation.file &&
           Math.abs(flow1.sinkLocation.line - flow2.sourceLocation.line) < 50;
  }

  /**
   * 連鎖リスクを計算
   */
  private calculateChainedRisk(flow1: TaintFlow, flow2: TaintFlow): RiskLevel {
    const combined = Math.max(flow1.taintLevel, flow2.taintLevel);
    
    if (combined >= TaintLevel.HIGH) return RiskLevel.CRITICAL;
    if (combined >= TaintLevel.MEDIUM) return RiskLevel.HIGH;
    return RiskLevel.MEDIUM;
  }

  /**
   * 攻撃シナリオを生成
   */
  private generateAttackScenario(flow1: TaintFlow, flow2: TaintFlow): string {
    return `攻撃者は${flow1.description}を悪用して、${flow2.description}につなげる可能性があります。`;
  }

  /**
   * 推奨事項を生成
   */
  generateRecommendations(vulnerabilities: Vulnerability[]): VulnerabilityRecommendation[] {
    const recommendations: VulnerabilityRecommendation[] = [];

    for (const vuln of vulnerabilities) {
      const priority = this.mapSeverityToPriority(vuln.severity);
      const timeline = this.getTimelineBySeverity(vuln.severity);
      
      recommendations.push({
        priority,
        action: this.generateActionForVulnerability(vuln),
        timeline,
        technicalDetails: this.generateTechnicalDetails(vuln),
        references: this.getReferencesForVulnerability(vuln)
      });
    }

    return recommendations.sort((a, b) => 
      this.getPriorityOrder(a.priority) - this.getPriorityOrder(b.priority)
    );
  }

  /**
   * SeverityLevelを優先度にマッピング
   */
  private mapSeverityToPriority(severity: SeverityLevel): 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' {
    switch (severity) {
      case 'CRITICAL':
        return 'CRITICAL';
      case 'VERY_HIGH':
      case 'HIGH':
        return 'HIGH';
      case 'MODERATE':
        return 'MEDIUM';
      default:
        return 'LOW';
    }
  }

  /**
   * 深刻度に基づくタイムラインを取得
   */
  private getTimelineBySeverity(severity: SeverityLevel): string {
    switch (severity) {
      case 'CRITICAL':
        return '24時間以内';
      case 'VERY_HIGH':
      case 'HIGH':
        return '1週間以内';
      case 'MODERATE':
        return '2週間以内';
      default:
        return '1ヶ月以内';
    }
  }

  /**
   * 脆弱性に対するアクションを生成
   */
  private generateActionForVulnerability(vuln: Vulnerability): string {
    if (vuln.severity === 'CRITICAL') {
      return '即座に入力サニタイズとバリデーションを実装してください';
    }
    if (vuln.severity === 'HIGH' || vuln.severity === 'VERY_HIGH') {
      return '早急に入力サニタイズとバリデーションを実装してください';
    }
    return '入力サニタイズとバリデーションの実装を検討してください';
  }

  /**
   * 技術的詳細を生成
   */
  private generateTechnicalDetails(vuln: Vulnerability): string {
    if (vuln.description.includes('SQL')) {
      return 'パラメータ化クエリまたはプリペアドステートメントを使用してください';
    }
    if (vuln.description.includes('XSS')) {
      return 'HTMLエスケープとContent Security Policy (CSP)を実装してください';
    }
    if (vuln.description.includes('コマンド')) {
      return 'シェルエスケープまたはサブプロセスライブラリを使用してください';
    }
    return '適切な入力検証とサニタイズを実装してください';
  }

  /**
   * 脆弱性の参考リンクを取得
   */
  private getReferencesForVulnerability(vuln: Vulnerability): string[] {
    const references: string[] = [];
    
    if (vuln.cweId) {
      references.push(`https://cwe.mitre.org/data/definitions/${vuln.cweId}.html`);
    }
    
    references.push('https://owasp.org/www-project-top-ten/');
    
    return references;
  }

  /**
   * 優先度の順序を取得
   */
  private getPriorityOrder(priority: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW'): number {
    const order: Record<string, number> = {
      'CRITICAL': 0,
      'HIGH': 1,
      'MEDIUM': 2,
      'LOW': 3
    };
    return order[priority];
  }
}