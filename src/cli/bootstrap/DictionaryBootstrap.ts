import * as fs from 'fs';
import * as path from 'path';
import * as readline from 'readline';
import { DomainDictionary, DomainTerm, BusinessRule, LearningOptions } from '../../core/types';
import { DomainDictionaryManager } from '../../dictionary/core/dictionary';
import { LinterKnowledgeExtractor } from '../../dictionary/extractors/linter';
import { DictionaryLoader } from '../../dictionary/storage/loader';
import { errorHandler, ErrorType } from '../../utils/errorHandler';

/**
 * 辞書初期化ブートストラップ
 * 新規プロジェクトでの辞書セットアップとウィザード機能を提供
 */
export class DictionaryBootstrap {
  private rl: readline.Interface;
  private projectRoot: string;
  private configPath: string;
  private isTestEnvironment: boolean;

  constructor(projectRoot: string = process.cwd()) {
    this.projectRoot = projectRoot;
    this.configPath = path.join(projectRoot, '.rimorrc.json');
    this.isTestEnvironment = this.detectTestEnvironment();
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
  }

  /**
   * テスト環境を検出
   */
  private detectTestEnvironment(): boolean {
    return process.env.NODE_ENV === 'test' ||
           process.env.JEST_WORKER_ID !== undefined ||
           process.argv.some(arg => arg.includes('jest'));
  }

  /**
   * テスト環境では出力を抑制するログメソッド
   */
  private log(message: string): void {
    if (!this.isTestEnvironment) {
      console.log(message);
    }
  }

  /**
   * テスト環境でも出力するエラー・警告ログメソッド
   */
  private warn(message: string): void {
    if (!this.isTestEnvironment) {
      console.warn(message);
    }
  }

  /**
   * メインのブートストラップワークフロー
   */
  async runBootstrap(): Promise<void> {
    try {
      this.log('🚀 Rimor ドメイン辞書セットアップウィザードへようこそ！\n');
      
      // 既存設定の確認
      const hasExistingConfig = await this.checkExistingConfiguration();
      if (hasExistingConfig) {
        const shouldOverwrite = await this.askQuestion(
          '既存の設定が見つかりました。上書きしますか？ (y/N): '
        );
        if (shouldOverwrite.toLowerCase() !== 'y') {
          this.log('ブートストラップを中止しました。');
          return;
        }
      }

      // プロジェクト情報の収集
      const projectInfo = await this.collectProjectInfo();
      
      // 辞書の初期化方法を選択
      const initMethod = await this.selectInitializationMethod();
      
      let dictionary: DomainDictionary;
      
      switch (initMethod) {
        case 'auto':
          dictionary = await this.autoGenerateDictionary(projectInfo);
          break;
        case 'manual':
          dictionary = await this.manualDictionarySetup(projectInfo);
          break;
        case 'import':
          dictionary = await this.importExistingDictionary(projectInfo);
          break;
        default:
          throw new Error('無効な初期化方法が選択されました');
      }

      // 設定ファイルの生成
      await this.generateConfiguration(projectInfo, dictionary);
      
      // 初期テストの実行
      await this.runInitialValidation(dictionary);
      
      this.log('\n✅ ブートストラップが完了しました！');
      this.log('次のコマンドで辞書を使用できます:');
      this.log('  npm run analyze -- --dictionary');
      this.log('  rimor dictionary list');
      this.log('  rimor dictionary validate\n');
      
    } catch (error) {
      errorHandler.handleError(error, ErrorType.SYSTEM_ERROR, 'ブートストラップ中にエラーが発生しました');
      throw error;
    } finally {
      this.rl.close();
    }
  }

  /**
   * 既存設定の確認
   */
  private async checkExistingConfiguration(): Promise<boolean> {
    const configExists = fs.existsSync(this.configPath);
    const dictionaryDir = path.join(this.projectRoot, '.rimor', 'dictionaries');
    const dictionaryExists = fs.existsSync(dictionaryDir) && 
                            fs.readdirSync(dictionaryDir).length > 0;
    
    return configExists || dictionaryExists;
  }

  /**
   * プロジェクト情報の収集
   */
  private async collectProjectInfo(): Promise<{
    domain: string;
    language: string;
    framework: string;
    projectType: string;
  }> {
    this.log('📋 プロジェクト情報を収集しています...\n');
    
    const domain = await this.askQuestion('ドメイン名を入力してください (例: ecommerce, financial): ');
    const language = await this.askQuestion('使用言語を選択してください (typescript/javascript/python/java) [typescript]: ') || 'typescript';
    const framework = await this.askQuestion('テストフレームワークを入力してください (jest/mocha/vitest) [jest]: ') || 'jest';
    const projectType = await this.askQuestion('プロジェクトタイプを選択してください (web/api/mobile/desktop) [web]: ') || 'web';
    
    return {
      domain: domain.trim(),
      language: language.trim(),
      framework: framework.trim(),
      projectType: projectType.trim()
    };
  }

  /**
   * 初期化方法の選択
   */
  private async selectInitializationMethod(): Promise<'auto' | 'manual' | 'import'> {
    this.log('\n🔧 辞書の初期化方法を選択してください:');
    this.log('1. 自動生成 (既存コードから知識を抽出)');
    this.log('2. 手動設定 (対話的に辞書を作成)');
    this.log('3. インポート (既存の辞書ファイルを使用)');
    
    const choice = await this.askQuestion('選択肢を入力してください (1-3) [1]: ') || '1';
    
    switch (choice) {
      case '1': return 'auto';
      case '2': return 'manual';
      case '3': return 'import';
      default: 
        this.log('無効な選択です。自動生成を使用します。');
        return 'auto';
    }
  }

  /**
   * 自動辞書生成
   */
  private async autoGenerateDictionary(projectInfo: any): Promise<DomainDictionary> {
    this.log('\n🤖 既存コードから辞書を自動生成しています...');
    
    try {
      // Linter設定ファイルの自動検出
      const linterConfigs = await LinterKnowledgeExtractor.autoDetectConfigs(this.projectRoot);
      this.log(`📍 検出された設定ファイル: ${JSON.stringify(linterConfigs)}`);
      
      // 知識抽出オプション
      const learningOptions: LearningOptions = {
        includeComments: true,
        includeTests: true,
        minFrequency: 2,
        maxTerms: 50
      };

      // 知識抽出の実行
      const extractedKnowledge = await LinterKnowledgeExtractor.extractFromLinters(
        linterConfigs,
        learningOptions
      );

      // 基本辞書の作成
      const dictionaryManager = new DomainDictionaryManager({
        domain: projectInfo.domain,
        language: 'ja',
        version: '1.0.0'
      });

      // 抽出された用語の追加
      for (const termData of extractedKnowledge.terms) {
        dictionaryManager.addTerm(termData);
      }

      // 抽出されたルールの追加（InferredRule → BusinessRuleに変換）
      for (const inferredRule of extractedKnowledge.rules) {
        const businessRule: BusinessRule = {
          id: inferredRule.id,
          name: inferredRule.name,
          description: `Auto-inferred rule from project configuration (confidence: ${Math.round(inferredRule.confidence * 100)}%)`,
          domain: projectInfo.domain,
          condition: {
            type: 'code-pattern',
            pattern: inferredRule.pattern,
            scope: 'function'
          },
          requirements: inferredRule.suggestedRequirements,
          priority: Math.round(inferredRule.confidence * 10)
        };
        dictionaryManager.addBusinessRule(businessRule);
      }

      this.log(`✅ 辞書を自動生成しました (用語: ${extractedKnowledge.terms.length}, ルール: ${extractedKnowledge.rules.length})`);
      
      return dictionaryManager.getDictionary();
    } catch (error) {
      this.warn('⚠️  自動生成に失敗しました。基本辞書を作成します。');
      return this.createBasicDictionary(projectInfo);
    }
  }

  /**
   * 手動辞書セットアップ
   */
  private async manualDictionarySetup(projectInfo: any): Promise<DomainDictionary> {
    this.log('\n✏️  手動で辞書を設定しています...');
    
    const dictionaryManager = new DomainDictionaryManager({
      domain: projectInfo.domain,
      language: 'ja',
      version: '1.0.0'
    });

    // 基本用語の追加
    const addMoreTerms = true;
    let termCount = 0;
    
    while (addMoreTerms && termCount < 10) {
      this.log(`\n--- 用語 ${termCount + 1} の追加 ---`);
      
      const termName = await this.askQuestion('用語名を入力してください (空白でスキップ): ');
      if (!termName.trim()) break;
      
      const definition = await this.askQuestion('定義を入力してください: ');
      const category = await this.askQuestion('カテゴリを入力してください (business/technical/domain) [business]: ') || 'business';
      const importance = await this.askQuestion('重要度を入力してください (critical/high/medium/low) [medium]: ') || 'medium';
      
      const aliases = await this.askQuestion('エイリアス（別名）をカンマ区切りで入力してください (省略可): ');
      const aliasArray = aliases ? aliases.split(',').map(a => a.trim()) : [];

      try {
        const term: DomainTerm = {
          id: `${termName.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}`,
          term: termName,
          definition: definition,
          category: category as any,
          importance: importance as any,
          aliases: aliasArray,
          examples: [{
            code: `// ${termName}の使用例`,
            description: `${termName}の基本的な使用方法`
          }],
          relatedPatterns: [`${termName.toLowerCase()}.*`],
          testRequirements: [`${termName}のテストが必要`]
        };

        dictionaryManager.addTerm(term);
        termCount++;
        
        this.log(`✅ 用語 "${termName}" を追加しました`);
        
        const continueAdding = await this.askQuestion('他の用語も追加しますか？ (y/N): ');
        if (continueAdding.toLowerCase() !== 'y') break;
        
      } catch (error) {
        this.warn(`⚠️  用語 "${termName}" の追加に失敗しました: ${error}`);
      }
    }

    this.log(`✅ 手動辞書セットアップが完了しました (${termCount}個の用語)`);
    return dictionaryManager.getDictionary();
  }

  /**
   * 既存辞書のインポート
   */
  private async importExistingDictionary(projectInfo: any): Promise<DomainDictionary> {
    this.log('\n📥 既存の辞書ファイルをインポートしています...');
    
    const dictionaryPath = await this.askQuestion('辞書ファイルのパスを入力してください: ');
    
    try {
      const resolvedPath = path.resolve(this.projectRoot, dictionaryPath);
      
      if (!fs.existsSync(resolvedPath)) {
        throw new Error(`ファイルが見つかりません: ${resolvedPath}`);
      }

      const dictionary = await DictionaryLoader.loadFromFile(resolvedPath);
      
      if (!dictionary) {
        throw new Error('辞書の読み込みに失敗しました');
      }

      this.log(`✅ 辞書をインポートしました: ${dictionary.terms.length}個の用語, ${dictionary.businessRules.length}個のルール`);
      return dictionary;
      
    } catch (error) {
      this.warn(`⚠️  インポートに失敗しました: ${error}`);
      this.log('基本辞書を作成します...');
      return this.createBasicDictionary(projectInfo);
    }
  }

  /**
   * 基本辞書の作成
   */
  private createBasicDictionary(projectInfo: any): DomainDictionary {
    const dictionaryManager = new DomainDictionaryManager({
      domain: projectInfo.domain,
      language: 'ja',
      version: '1.0.0'
    });

    // ドメインに応じた基本用語を追加
    const basicTerms = this.getBasicTermsForDomain(projectInfo.domain);
    
    for (const termData of basicTerms) {
      try {
        dictionaryManager.addTerm(termData);
      } catch (error) {
        this.warn(`基本用語 "${termData.term}" の追加に失敗しました`);
      }
    }

    return dictionaryManager.getDictionary();
  }

  /**
   * ドメイン固有の基本用語を取得
   */
  private getBasicTermsForDomain(domain: string): DomainTerm[] {
    const commonTerms: DomainTerm[] = [
      {
        id: 'user-basic',
        term: 'User',
        definition: 'システムのユーザー',
        category: 'core-business',
        importance: 'high',
        aliases: ['ユーザー', 'user'],
        examples: [{ code: 'createUser(userData)', description: 'ユーザー作成の例' }],
        relatedPatterns: ['user.*', 'User.*'],
        testRequirements: ['ユーザー作成テスト', 'ユーザー認証テスト']
      }
    ];

    // ドメイン固有の用語
    const domainSpecificTerms: Record<string, DomainTerm[]> = {
      'ecommerce': [
        {
          id: 'product-ecommerce',
          term: 'Product',
          definition: '販売する商品',
          category: 'core-business',
          importance: 'critical',
          aliases: ['商品', 'product', 'item'],
          examples: [{ code: 'createProduct(productData)', description: '商品作成の例' }],
          relatedPatterns: ['product.*', 'Product.*'],
          testRequirements: ['商品作成テスト', '商品検索テスト']
        },
        {
          id: 'payment-ecommerce',
          term: 'Payment',
          definition: '決済処理',
          category: 'financial',
          importance: 'critical',
          aliases: ['決済', 'payment', 'pay'],
          examples: [{ code: 'processPayment(amount, currency)', description: '決済処理の例' }],
          relatedPatterns: ['payment.*', 'pay.*'],
          testRequirements: ['決済処理テスト', '決済失敗テスト']
        }
      ],
      'financial': [
        {
          id: 'transaction-financial',
          term: 'Transaction',
          definition: '金融取引',
          category: 'financial',
          importance: 'critical',
          aliases: ['取引', 'transaction', 'tx'],
          examples: [{ code: 'createTransaction(fromAccount, toAccount, amount)', description: '取引作成の例' }],
          relatedPatterns: ['transaction.*', 'Transaction.*'],
          testRequirements: ['取引作成テスト', '残高確認テスト']
        }
      ]
    };

    return [...commonTerms, ...(domainSpecificTerms[domain] || [])];
  }

  /**
   * 設定ファイルの生成
   */
  private async generateConfiguration(projectInfo: any, dictionary: DomainDictionary): Promise<void> {
    this.log('\n⚙️  設定ファイルを生成しています...');
    
    const config = {
      version: '1.0.0',
      project: {
        domain: projectInfo.domain,
        language: projectInfo.language,
        framework: projectInfo.framework,
        type: projectInfo.projectType
      },
      dictionary: {
        enabled: true,
        defaultDomain: projectInfo.domain,
        autoUpdate: true,
        paths: {
          dictionaries: '.rimor/dictionaries',
          cache: '.rimor/cache'
        }
      },
      plugins: {
        enabled: ['domain-term-coverage'],
        disabled: []
      },
      analysis: {
        includeTests: true,
        includeComments: false,
        minConfidence: 0.7
      },
      bootstrap: {
        completed: true,
        version: '1.0.0',
        timestamp: new Date().toISOString()
      }
    };

    // 設定ファイルの書き込み
    fs.writeFileSync(this.configPath, JSON.stringify(config, null, 2), 'utf-8');
    this.log(`✅ 設定ファイルを作成しました: ${this.configPath}`);

    // 辞書ディレクトリの作成
    const dictionaryDir = path.join(this.projectRoot, '.rimor', 'dictionaries');
    if (!fs.existsSync(dictionaryDir)) {
      fs.mkdirSync(dictionaryDir, { recursive: true });
    }

    // 辞書ファイルの保存
    const dictionaryPath = path.join(dictionaryDir, `${projectInfo.domain}.yaml`);
    await DictionaryLoader.saveToFile(dictionary, dictionaryPath);
    this.log(`✅ 辞書ファイルを保存しました: ${dictionaryPath}`);
  }

  /**
   * 初期検証の実行
   */
  private async runInitialValidation(dictionary: DomainDictionary): Promise<void> {
    this.log('\n🔍 初期検証を実行しています...');
    
    try {
      // 辞書の基本検証
      const termsCount = dictionary.terms.length;
      const rulesCount = dictionary.businessRules.length;
      
      this.log(`📊 検証結果:`);
      this.log(`  - 用語数: ${termsCount}`);
      this.log(`  - ルール数: ${rulesCount}`);
      this.log(`  - ドメイン: ${dictionary.domain}`);
      this.log(`  - バージョン: ${dictionary.version}`);
      
      if (termsCount === 0) {
        this.warn('⚠️  辞書に用語が含まれていません。後で追加することをお勧めします。');
      }
      
      if (termsCount > 0) {
        this.log('✅ 辞書の基本検証が完了しました');
      }
      
    } catch (error) {
      this.warn(`⚠️  検証中に問題が発生しました: ${error}`);
    }
  }

  /**
   * 質問プロンプトのヘルパー
   */
  private askQuestion(question: string): Promise<string> {
    return new Promise((resolve) => {
      this.rl.question(question, (answer) => {
        resolve(answer);
      });
    });
  }

  /**
   * リソースのクリーンアップ
   */
  close(): void {
    this.rl.close();
  }
}