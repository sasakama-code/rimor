import * as fs from 'fs';
import * as path from 'path';
import * as readline from 'readline';
import { DomainDictionary, DomainTerm, BusinessRule, LearningOptions } from '../../core/types';
import { DomainDictionaryManager } from '../../dictionary/core/dictionary';
import { LinterKnowledgeExtractor } from '../../dictionary/extractors/linter';
import { DictionaryLoader } from '../../dictionary/storage/loader';
import { errorHandler, ErrorType } from '../../utils/errorHandler';

/**
 * è¾æ›¸åˆæœŸåŒ–ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—
 * æ–°è¦ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã®è¾æ›¸ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã¨ã‚¦ã‚£ã‚¶ãƒ¼ãƒ‰æ©Ÿèƒ½ã‚’æä¾›
 */
export class DictionaryBootstrap {
  private rl: readline.Interface;
  private projectRoot: string;
  private configPath: string;
  private isTestEnvironment: boolean;

  constructor(projectRoot: string = process.cwd()) {
    this.projectRoot = projectRoot;
    this.configPath = path.join(projectRoot, '.rimorrc.json');
    this.isTestEnvironment = this.detectTestEnvironment();
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
  }

  /**
   * ãƒ†ã‚¹ãƒˆç’°å¢ƒã‚’æ¤œå‡º
   */
  private detectTestEnvironment(): boolean {
    return process.env.NODE_ENV === 'test' ||
           process.env.JEST_WORKER_ID !== undefined ||
           process.argv.some(arg => arg.includes('jest'));
  }

  /**
   * ãƒ†ã‚¹ãƒˆç’°å¢ƒã§ã¯å‡ºåŠ›ã‚’æŠ‘åˆ¶ã™ã‚‹ãƒ­ã‚°ãƒ¡ã‚½ãƒƒãƒ‰
   */
  private log(message: string): void {
    if (!this.isTestEnvironment) {
      console.log(message);
    }
  }

  /**
   * ãƒ†ã‚¹ãƒˆç’°å¢ƒã§ã‚‚å‡ºåŠ›ã™ã‚‹ã‚¨ãƒ©ãƒ¼ãƒ»è­¦å‘Šãƒ­ã‚°ãƒ¡ã‚½ãƒƒãƒ‰
   */
  private warn(message: string): void {
    if (!this.isTestEnvironment) {
      console.warn(message);
    }
  }

  /**
   * ãƒ¡ã‚¤ãƒ³ã®ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
   */
  async runBootstrap(): Promise<void> {
    try {
      this.log('ğŸš€ Rimor ãƒ‰ãƒ¡ã‚¤ãƒ³è¾æ›¸ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¦ã‚£ã‚¶ãƒ¼ãƒ‰ã¸ã‚ˆã†ã“ãï¼\n');
      
      // æ—¢å­˜è¨­å®šã®ç¢ºèª
      const hasExistingConfig = await this.checkExistingConfiguration();
      if (hasExistingConfig) {
        const shouldOverwrite = await this.askQuestion(
          'æ—¢å­˜ã®è¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚ä¸Šæ›¸ãã—ã¾ã™ã‹ï¼Ÿ (y/N): '
        );
        if (shouldOverwrite.toLowerCase() !== 'y') {
          this.log('ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—ã‚’ä¸­æ­¢ã—ã¾ã—ãŸã€‚');
          return;
        }
      }

      // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±ã®åé›†
      const projectInfo = await this.collectProjectInfo();
      
      // è¾æ›¸ã®åˆæœŸåŒ–æ–¹æ³•ã‚’é¸æŠ
      const initMethod = await this.selectInitializationMethod();
      
      let dictionary: DomainDictionary;
      
      switch (initMethod) {
        case 'auto':
          dictionary = await this.autoGenerateDictionary(projectInfo);
          break;
        case 'manual':
          dictionary = await this.manualDictionarySetup(projectInfo);
          break;
        case 'import':
          dictionary = await this.importExistingDictionary(projectInfo);
          break;
        default:
          throw new Error('ç„¡åŠ¹ãªåˆæœŸåŒ–æ–¹æ³•ãŒé¸æŠã•ã‚Œã¾ã—ãŸ');
      }

      // è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆ
      await this.generateConfiguration(projectInfo, dictionary);
      
      // åˆæœŸãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ
      await this.runInitialValidation(dictionary);
      
      this.log('\nâœ… ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—ãŒå®Œäº†ã—ã¾ã—ãŸï¼');
      this.log('æ¬¡ã®ã‚³ãƒãƒ³ãƒ‰ã§è¾æ›¸ã‚’ä½¿ç”¨ã§ãã¾ã™:');
      this.log('  npm run analyze -- --dictionary');
      this.log('  rimor dictionary list');
      this.log('  rimor dictionary validate\n');
      
    } catch (error) {
      errorHandler.handleError(error, ErrorType.SYSTEM_ERROR, 'ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
      throw error;
    } finally {
      this.rl.close();
    }
  }

  /**
   * æ—¢å­˜è¨­å®šã®ç¢ºèª
   */
  private async checkExistingConfiguration(): Promise<boolean> {
    const configExists = fs.existsSync(this.configPath);
    const dictionaryDir = path.join(this.projectRoot, '.rimor', 'dictionaries');
    const dictionaryExists = fs.existsSync(dictionaryDir) && 
                            fs.readdirSync(dictionaryDir).length > 0;
    
    return configExists || dictionaryExists;
  }

  /**
   * ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±ã®åé›†
   */
  private async collectProjectInfo(): Promise<{
    domain: string;
    language: string;
    framework: string;
    projectType: string;
  }> {
    this.log('ğŸ“‹ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±ã‚’åé›†ã—ã¦ã„ã¾ã™...\n');
    
    const domain = await this.askQuestion('ãƒ‰ãƒ¡ã‚¤ãƒ³åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (ä¾‹: ecommerce, financial): ');
    const language = await this.askQuestion('ä½¿ç”¨è¨€èªã‚’é¸æŠã—ã¦ãã ã•ã„ (typescript/javascript/python/java) [typescript]: ') || 'typescript';
    const framework = await this.askQuestion('ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (jest/mocha/vitest) [jest]: ') || 'jest';
    const projectType = await this.askQuestion('ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—ã‚’é¸æŠã—ã¦ãã ã•ã„ (web/api/mobile/desktop) [web]: ') || 'web';
    
    return {
      domain: domain.trim(),
      language: language.trim(),
      framework: framework.trim(),
      projectType: projectType.trim()
    };
  }

  /**
   * åˆæœŸåŒ–æ–¹æ³•ã®é¸æŠ
   */
  private async selectInitializationMethod(): Promise<'auto' | 'manual' | 'import'> {
    this.log('\nğŸ”§ è¾æ›¸ã®åˆæœŸåŒ–æ–¹æ³•ã‚’é¸æŠã—ã¦ãã ã•ã„:');
    this.log('1. è‡ªå‹•ç”Ÿæˆ (æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã‹ã‚‰çŸ¥è­˜ã‚’æŠ½å‡º)');
    this.log('2. æ‰‹å‹•è¨­å®š (å¯¾è©±çš„ã«è¾æ›¸ã‚’ä½œæˆ)');
    this.log('3. ã‚¤ãƒ³ãƒãƒ¼ãƒˆ (æ—¢å­˜ã®è¾æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨)');
    
    const choice = await this.askQuestion('é¸æŠè‚¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (1-3) [1]: ') || '1';
    
    switch (choice) {
      case '1': return 'auto';
      case '2': return 'manual';
      case '3': return 'import';
      default: 
        this.log('ç„¡åŠ¹ãªé¸æŠã§ã™ã€‚è‡ªå‹•ç”Ÿæˆã‚’ä½¿ç”¨ã—ã¾ã™ã€‚');
        return 'auto';
    }
  }

  /**
   * è‡ªå‹•è¾æ›¸ç”Ÿæˆ
   */
  private async autoGenerateDictionary(projectInfo: any): Promise<DomainDictionary> {
    this.log('\nğŸ¤– æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã‹ã‚‰è¾æ›¸ã‚’è‡ªå‹•ç”Ÿæˆã—ã¦ã„ã¾ã™...');
    
    try {
      // Linterè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®è‡ªå‹•æ¤œå‡º
      const linterConfigs = await LinterKnowledgeExtractor.autoDetectConfigs(this.projectRoot);
      this.log(`ğŸ“ æ¤œå‡ºã•ã‚ŒãŸè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«: ${JSON.stringify(linterConfigs)}`);
      
      // çŸ¥è­˜æŠ½å‡ºã‚ªãƒ—ã‚·ãƒ§ãƒ³
      const learningOptions: LearningOptions = {
        includeComments: true,
        includeTests: true,
        minFrequency: 2,
        maxTerms: 50
      };

      // çŸ¥è­˜æŠ½å‡ºã®å®Ÿè¡Œ
      const extractedKnowledge = await LinterKnowledgeExtractor.extractFromLinters(
        linterConfigs,
        learningOptions
      );

      // åŸºæœ¬è¾æ›¸ã®ä½œæˆ
      const dictionaryManager = new DomainDictionaryManager({
        domain: projectInfo.domain,
        language: 'ja',
        version: '1.0.0'
      });

      // æŠ½å‡ºã•ã‚ŒãŸç”¨èªã®è¿½åŠ 
      for (const termData of extractedKnowledge.terms) {
        dictionaryManager.addTerm(termData);
      }

      // æŠ½å‡ºã•ã‚ŒãŸãƒ«ãƒ¼ãƒ«ã®è¿½åŠ ï¼ˆInferredRule â†’ BusinessRuleã«å¤‰æ›ï¼‰
      for (const inferredRule of extractedKnowledge.rules) {
        const businessRule: BusinessRule = {
          id: inferredRule.id,
          name: inferredRule.name,
          description: `Auto-inferred rule from project configuration (confidence: ${Math.round(inferredRule.confidence * 100)}%)`,
          domain: projectInfo.domain,
          condition: {
            type: 'code-pattern',
            pattern: inferredRule.pattern,
            scope: 'function'
          },
          requirements: inferredRule.suggestedRequirements,
          priority: Math.round(inferredRule.confidence * 10)
        };
        dictionaryManager.addBusinessRule(businessRule);
      }

      this.log(`âœ… è¾æ›¸ã‚’è‡ªå‹•ç”Ÿæˆã—ã¾ã—ãŸ (ç”¨èª: ${extractedKnowledge.terms.length}, ãƒ«ãƒ¼ãƒ«: ${extractedKnowledge.rules.length})`);
      
      return dictionaryManager.getDictionary();
    } catch (error) {
      this.warn('âš ï¸  è‡ªå‹•ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚åŸºæœ¬è¾æ›¸ã‚’ä½œæˆã—ã¾ã™ã€‚');
      return this.createBasicDictionary(projectInfo);
    }
  }

  /**
   * æ‰‹å‹•è¾æ›¸ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
   */
  private async manualDictionarySetup(projectInfo: any): Promise<DomainDictionary> {
    this.log('\nâœï¸  æ‰‹å‹•ã§è¾æ›¸ã‚’è¨­å®šã—ã¦ã„ã¾ã™...');
    
    const dictionaryManager = new DomainDictionaryManager({
      domain: projectInfo.domain,
      language: 'ja',
      version: '1.0.0'
    });

    // åŸºæœ¬ç”¨èªã®è¿½åŠ 
    const addMoreTerms = true;
    let termCount = 0;
    
    while (addMoreTerms && termCount < 10) {
      this.log(`\n--- ç”¨èª ${termCount + 1} ã®è¿½åŠ  ---`);
      
      const termName = await this.askQuestion('ç”¨èªåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (ç©ºç™½ã§ã‚¹ã‚­ãƒƒãƒ—): ');
      if (!termName.trim()) break;
      
      const definition = await this.askQuestion('å®šç¾©ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„: ');
      const category = await this.askQuestion('ã‚«ãƒ†ã‚´ãƒªã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (business/technical/domain) [business]: ') || 'business';
      const importance = await this.askQuestion('é‡è¦åº¦ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (critical/high/medium/low) [medium]: ') || 'medium';
      
      const aliases = await this.askQuestion('ã‚¨ã‚¤ãƒªã‚¢ã‚¹ï¼ˆåˆ¥åï¼‰ã‚’ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã§å…¥åŠ›ã—ã¦ãã ã•ã„ (çœç•¥å¯): ');
      const aliasArray = aliases ? aliases.split(',').map(a => a.trim()) : [];

      try {
        const term: DomainTerm = {
          id: `${termName.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}`,
          term: termName,
          definition: definition,
          category: category as any,
          importance: importance as any,
          aliases: aliasArray,
          examples: [{
            code: `// ${termName}ã®ä½¿ç”¨ä¾‹`,
            description: `${termName}ã®åŸºæœ¬çš„ãªä½¿ç”¨æ–¹æ³•`
          }],
          relatedPatterns: [`${termName.toLowerCase()}.*`],
          testRequirements: [`${termName}ã®ãƒ†ã‚¹ãƒˆãŒå¿…è¦`]
        };

        dictionaryManager.addTerm(term);
        termCount++;
        
        this.log(`âœ… ç”¨èª "${termName}" ã‚’è¿½åŠ ã—ã¾ã—ãŸ`);
        
        const continueAdding = await this.askQuestion('ä»–ã®ç”¨èªã‚‚è¿½åŠ ã—ã¾ã™ã‹ï¼Ÿ (y/N): ');
        if (continueAdding.toLowerCase() !== 'y') break;
        
      } catch (error) {
        this.warn(`âš ï¸  ç”¨èª "${termName}" ã®è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error}`);
      }
    }

    this.log(`âœ… æ‰‹å‹•è¾æ›¸ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãŒå®Œäº†ã—ã¾ã—ãŸ (${termCount}å€‹ã®ç”¨èª)`);
    return dictionaryManager.getDictionary();
  }

  /**
   * æ—¢å­˜è¾æ›¸ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
   */
  private async importExistingDictionary(projectInfo: any): Promise<DomainDictionary> {
    this.log('\nğŸ“¥ æ—¢å­˜ã®è¾æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™...');
    
    const dictionaryPath = await this.askQuestion('è¾æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„: ');
    
    try {
      const resolvedPath = path.resolve(this.projectRoot, dictionaryPath);
      
      if (!fs.existsSync(resolvedPath)) {
        throw new Error(`ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${resolvedPath}`);
      }

      const dictionary = await DictionaryLoader.loadFromFile(resolvedPath);
      
      if (!dictionary) {
        throw new Error('è¾æ›¸ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      this.log(`âœ… è¾æ›¸ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ: ${dictionary.terms.length}å€‹ã®ç”¨èª, ${dictionary.businessRules.length}å€‹ã®ãƒ«ãƒ¼ãƒ«`);
      return dictionary;
      
    } catch (error) {
      this.warn(`âš ï¸  ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${error}`);
      this.log('åŸºæœ¬è¾æ›¸ã‚’ä½œæˆã—ã¾ã™...');
      return this.createBasicDictionary(projectInfo);
    }
  }

  /**
   * åŸºæœ¬è¾æ›¸ã®ä½œæˆ
   */
  private createBasicDictionary(projectInfo: any): DomainDictionary {
    const dictionaryManager = new DomainDictionaryManager({
      domain: projectInfo.domain,
      language: 'ja',
      version: '1.0.0'
    });

    // ãƒ‰ãƒ¡ã‚¤ãƒ³ã«å¿œã˜ãŸåŸºæœ¬ç”¨èªã‚’è¿½åŠ 
    const basicTerms = this.getBasicTermsForDomain(projectInfo.domain);
    
    for (const termData of basicTerms) {
      try {
        dictionaryManager.addTerm(termData);
      } catch (error) {
        this.warn(`åŸºæœ¬ç”¨èª "${termData.term}" ã®è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ`);
      }
    }

    return dictionaryManager.getDictionary();
  }

  /**
   * ãƒ‰ãƒ¡ã‚¤ãƒ³å›ºæœ‰ã®åŸºæœ¬ç”¨èªã‚’å–å¾—
   */
  private getBasicTermsForDomain(domain: string): DomainTerm[] {
    const commonTerms: DomainTerm[] = [
      {
        id: 'user-basic',
        term: 'User',
        definition: 'ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼',
        category: 'core-business',
        importance: 'high',
        aliases: ['ãƒ¦ãƒ¼ã‚¶ãƒ¼', 'user'],
        examples: [{ code: 'createUser(userData)', description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆã®ä¾‹' }],
        relatedPatterns: ['user.*', 'User.*'],
        testRequirements: ['ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆãƒ†ã‚¹ãƒˆ', 'ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ãƒ†ã‚¹ãƒˆ']
      }
    ];

    // ãƒ‰ãƒ¡ã‚¤ãƒ³å›ºæœ‰ã®ç”¨èª
    const domainSpecificTerms: Record<string, DomainTerm[]> = {
      'ecommerce': [
        {
          id: 'product-ecommerce',
          term: 'Product',
          definition: 'è²©å£²ã™ã‚‹å•†å“',
          category: 'core-business',
          importance: 'critical',
          aliases: ['å•†å“', 'product', 'item'],
          examples: [{ code: 'createProduct(productData)', description: 'å•†å“ä½œæˆã®ä¾‹' }],
          relatedPatterns: ['product.*', 'Product.*'],
          testRequirements: ['å•†å“ä½œæˆãƒ†ã‚¹ãƒˆ', 'å•†å“æ¤œç´¢ãƒ†ã‚¹ãƒˆ']
        },
        {
          id: 'payment-ecommerce',
          term: 'Payment',
          definition: 'æ±ºæ¸ˆå‡¦ç†',
          category: 'financial',
          importance: 'critical',
          aliases: ['æ±ºæ¸ˆ', 'payment', 'pay'],
          examples: [{ code: 'processPayment(amount, currency)', description: 'æ±ºæ¸ˆå‡¦ç†ã®ä¾‹' }],
          relatedPatterns: ['payment.*', 'pay.*'],
          testRequirements: ['æ±ºæ¸ˆå‡¦ç†ãƒ†ã‚¹ãƒˆ', 'æ±ºæ¸ˆå¤±æ•—ãƒ†ã‚¹ãƒˆ']
        }
      ],
      'financial': [
        {
          id: 'transaction-financial',
          term: 'Transaction',
          definition: 'é‡‘èå–å¼•',
          category: 'financial',
          importance: 'critical',
          aliases: ['å–å¼•', 'transaction', 'tx'],
          examples: [{ code: 'createTransaction(fromAccount, toAccount, amount)', description: 'å–å¼•ä½œæˆã®ä¾‹' }],
          relatedPatterns: ['transaction.*', 'Transaction.*'],
          testRequirements: ['å–å¼•ä½œæˆãƒ†ã‚¹ãƒˆ', 'æ®‹é«˜ç¢ºèªãƒ†ã‚¹ãƒˆ']
        }
      ]
    };

    return [...commonTerms, ...(domainSpecificTerms[domain] || [])];
  }

  /**
   * è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆ
   */
  private async generateConfiguration(projectInfo: any, dictionary: DomainDictionary): Promise<void> {
    this.log('\nâš™ï¸  è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã—ã¦ã„ã¾ã™...');
    
    const config = {
      version: '1.0.0',
      project: {
        domain: projectInfo.domain,
        language: projectInfo.language,
        framework: projectInfo.framework,
        type: projectInfo.projectType
      },
      dictionary: {
        enabled: true,
        defaultDomain: projectInfo.domain,
        autoUpdate: true,
        paths: {
          dictionaries: '.rimor/dictionaries',
          cache: '.rimor/cache'
        }
      },
      plugins: {
        enabled: ['domain-term-coverage'],
        disabled: []
      },
      analysis: {
        includeTests: true,
        includeComments: false,
        minConfidence: 0.7
      },
      bootstrap: {
        completed: true,
        version: '1.0.0',
        timestamp: new Date().toISOString()
      }
    };

    // è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®æ›¸ãè¾¼ã¿
    fs.writeFileSync(this.configPath, JSON.stringify(config, null, 2), 'utf-8');
    this.log(`âœ… è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¾ã—ãŸ: ${this.configPath}`);

    // è¾æ›¸ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ä½œæˆ
    const dictionaryDir = path.join(this.projectRoot, '.rimor', 'dictionaries');
    if (!fs.existsSync(dictionaryDir)) {
      fs.mkdirSync(dictionaryDir, { recursive: true });
    }

    // è¾æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜
    const dictionaryPath = path.join(dictionaryDir, `${projectInfo.domain}.yaml`);
    await DictionaryLoader.saveToFile(dictionary, dictionaryPath);
    this.log(`âœ… è¾æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã—ã¾ã—ãŸ: ${dictionaryPath}`);
  }

  /**
   * åˆæœŸæ¤œè¨¼ã®å®Ÿè¡Œ
   */
  private async runInitialValidation(dictionary: DomainDictionary): Promise<void> {
    this.log('\nğŸ” åˆæœŸæ¤œè¨¼ã‚’å®Ÿè¡Œã—ã¦ã„ã¾ã™...');
    
    try {
      // è¾æ›¸ã®åŸºæœ¬æ¤œè¨¼
      const termsCount = dictionary.terms.length;
      const rulesCount = dictionary.businessRules.length;
      
      this.log(`ğŸ“Š æ¤œè¨¼çµæœ:`);
      this.log(`  - ç”¨èªæ•°: ${termsCount}`);
      this.log(`  - ãƒ«ãƒ¼ãƒ«æ•°: ${rulesCount}`);
      this.log(`  - ãƒ‰ãƒ¡ã‚¤ãƒ³: ${dictionary.domain}`);
      this.log(`  - ãƒãƒ¼ã‚¸ãƒ§ãƒ³: ${dictionary.version}`);
      
      if (termsCount === 0) {
        this.warn('âš ï¸  è¾æ›¸ã«ç”¨èªãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚å¾Œã§è¿½åŠ ã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚');
      }
      
      if (termsCount > 0) {
        this.log('âœ… è¾æ›¸ã®åŸºæœ¬æ¤œè¨¼ãŒå®Œäº†ã—ã¾ã—ãŸ');
      }
      
    } catch (error) {
      this.warn(`âš ï¸  æ¤œè¨¼ä¸­ã«å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error}`);
    }
  }

  /**
   * è³ªå•ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®ãƒ˜ãƒ«ãƒ‘ãƒ¼
   */
  private askQuestion(question: string): Promise<string> {
    return new Promise((resolve) => {
      this.rl.question(question, (answer) => {
        resolve(answer);
      });
    });
  }

  /**
   * ãƒªã‚½ãƒ¼ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   */
  close(): void {
    this.rl.close();
  }
}