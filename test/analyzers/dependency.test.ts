import { DependencyAnalyzer } from '../../src/analyzers/dependency';
import { DependencyAnalysis, ProjectDependency, FileDependency, CyclicDependency } from '../../src/analyzers/types';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

describe('DependencyAnalyzer', () => {
  let analyzer: DependencyAnalyzer;
  let testProjectPath: string;

  beforeEach(() => {
    analyzer = new DependencyAnalyzer();
    
    // テスト用プロジェクトディレクトリを作成
    testProjectPath = fs.mkdtempSync(path.join(os.tmpdir(), 'rimor-dependency-test-'));
    
    // 複雑なpackage.jsonを作成
    const packageJson = {
      name: 'test-project',
      version: '1.0.0',
      description: 'Test project for dependency analysis',
      main: 'index.js',
      scripts: {
        test: 'jest',
        build: 'tsc',
        start: 'node dist/index.js'
      },
      dependencies: {
        'express': '^4.18.0',
        'lodash': '4.17.21',
        'axios': '~1.4.0',
        'moment': '>=2.29.0',
        'uuid': '^9.0.0'
      },
      devDependencies: {
        'jest': '^29.0.0',
        '@types/jest': '^29.0.0',
        '@types/express': '^4.17.0',
        '@types/node': '^20.0.0',
        'typescript': '^5.0.0',
        'ts-node': '^10.9.0'
      },
      peerDependencies: {
        'react': '>=16.0.0',
        'react-dom': '>=16.0.0'
      },
      optionalDependencies: {
        'fsevents': '^2.3.0'  // macOS only
      }
    };

    fs.writeFileSync(path.join(testProjectPath, 'package.json'), JSON.stringify(packageJson, null, 2));

    // yarn.lockファイルを作成
    const yarnLock = `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

axios@~1.4.0:
  version "1.4.0"
  resolved "https://registry.yarnpkg.com/axios/-/axios-1.4.0.tgz"
  integrity sha512-S4XCWMEmzvo64T9GfvQDOXgYRDJ/wsSZc7Jvdgx5u1sd0JwsuPLqb3SYmusag+edF6ziyMensPVqLTSc1PiSEA==

express@^4.18.0:
  version "4.18.2"
  resolved "https://registry.yarnpkg.com/express/-/express-4.18.2.tgz"
  integrity sha512-5/PsL6iGPdfQ/lKM1UuielYgv3BUoJfz1aUwU9vHZ+J7gyvwdQXFEBIEIaxeGf0GIcreATNyBExtalisDbuMqQ==

lodash@4.17.21:
  version "4.17.21"
  resolved "https://registry.yarnpkg.com/lodash/-/lodash-4.17.21.tgz"
  integrity sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==
`;

    fs.writeFileSync(path.join(testProjectPath, 'yarn.lock'), yarnLock);

    // テスト用のTypeScriptファイル群を作成
    fs.mkdirSync(path.join(testProjectPath, 'src'), { recursive: true });
    
    // index.ts
    const indexCode = `import express from 'express';
import { Request, Response } from 'express';
import { userRouter } from './routes/user';
import { authMiddleware } from './middleware/auth';
import * as config from './config/database';

const app = express();

app.use('/api/users', userRouter);
app.use(authMiddleware);

export default app;`;

    fs.writeFileSync(path.join(testProjectPath, 'src/index.ts'), indexCode);

    // routes/user.ts
    fs.mkdirSync(path.join(testProjectPath, 'src/routes'), { recursive: true });
    const userRouterCode = `import { Router } from 'express';
import { UserService } from '../services/userService';
import { validateUser } from '../utils/validation';
import _ from 'lodash';

const router = Router();
const userService = new UserService();

router.get('/', async (req, res) => {
  const users = await userService.getAllUsers();
  res.json(_.omit(users, 'password'));
});

export { router as userRouter };`;

    fs.writeFileSync(path.join(testProjectPath, 'src/routes/user.ts'), userRouterCode);

    // services/userService.ts
    fs.mkdirSync(path.join(testProjectPath, 'src/services'), { recursive: true });
    const userServiceCode = `import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';
import { DatabaseConnection } from './database';

export class UserService {
  private db: DatabaseConnection;

  constructor() {
    this.db = new DatabaseConnection();
  }

  async getAllUsers() {
    return await this.db.query('SELECT * FROM users');
  }

  async createUser(userData: any) {
    const id = uuidv4();
    return await this.db.query('INSERT INTO users VALUES (?)', [{ id, ...userData }]);
  }

  async fetchExternalData() {
    return await axios.get('https://api.example.com/data');
  }
}`;

    fs.writeFileSync(path.join(testProjectPath, 'src/services/userService.ts'), userServiceCode);

    // services/database.ts - 循環依存を作るため
    const databaseCode = `import { UserService } from './userService';

export class DatabaseConnection {
  private userService?: UserService;

  query(sql: string, params?: any[]) {
    // 循環依存のデモ
    if (!this.userService) {
      // this.userService = new UserService(); // これは循環依存を作る
    }
    return Promise.resolve([]);
  }
}`;

    fs.writeFileSync(path.join(testProjectPath, 'src/services/database.ts'), databaseCode);

    // middleware/auth.ts
    fs.mkdirSync(path.join(testProjectPath, 'src/middleware'), { recursive: true });
    const authCode = `import jwt from 'jsonwebtoken'; // 存在しない依存関係
import { Request, Response, NextFunction } from 'express';

export function authMiddleware(req: Request, res: Response, next: NextFunction) {
  const token = req.headers.authorization;
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  next();
}`;

    fs.writeFileSync(path.join(testProjectPath, 'src/middleware/auth.ts'), authCode);

    // utils/validation.ts
    fs.mkdirSync(path.join(testProjectPath, 'src/utils'), { recursive: true });
    const validationCode = `import moment from 'moment';
import Joi from 'joi'; // 未インストールの依存関係

export function validateUser(userData: any) {
  const schema = Joi.object({
    name: Joi.string().required(),
    email: Joi.string().email().required(),
    birthDate: Joi.date().max(moment().subtract(18, 'years')).required()
  });

  return schema.validate(userData);
}`;

    fs.writeFileSync(path.join(testProjectPath, 'src/utils/validation.ts'), validationCode);

    // config/database.ts
    fs.mkdirSync(path.join(testProjectPath, 'src/config'), { recursive: true });
    const configCode = `export const dbConfig = {
  host: 'localhost',
  port: 5432,
  database: 'testdb'
};`;

    fs.writeFileSync(path.join(testProjectPath, 'src/config/database.ts'), configCode);

    // tsconfig.json
    const tsConfig = {
      compilerOptions: {
        target: 'es2020',
        module: 'commonjs',
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        outDir: './dist',
        rootDir: './src'
      },
      include: ['src/**/*'],
      exclude: ['node_modules', 'dist']
    };

    fs.writeFileSync(path.join(testProjectPath, 'tsconfig.json'), JSON.stringify(tsConfig, null, 2));
  });

  afterEach(() => {
    if (fs.existsSync(testProjectPath)) {
      fs.rmSync(testProjectPath, { recursive: true, force: true });
    }
  });

  describe('Class Instantiation', () => {
    test('should create DependencyAnalyzer instance', () => {
      expect(analyzer).toBeInstanceOf(DependencyAnalyzer);
    });

    test('should have required public methods', () => {
      expect(typeof analyzer.analyzeDependencies).toBe('function');
      expect(typeof analyzer.detectCyclicDependencies).toBe('function');
      expect(typeof analyzer.findUnusedDependencies).toBe('function');
      expect(typeof analyzer.findMissingDependencies).toBe('function');
      expect(typeof analyzer.analyzeVersionConstraints).toBe('function');
    });
  });

  describe('analyzeDependencies', () => {
    test('should analyze all dependency types from package.json', async () => {
      const analysis = await analyzer.analyzeDependencies(testProjectPath);

      expect(analysis).toBeDefined();
      expect(analysis.projectDependencies).toHaveLength(14); // 5 deps + 6 devDeps + 2 peerDeps + 1 optionalDeps
      
      // Production dependencies
      const productionDeps = analysis.projectDependencies.filter(dep => dep.type === 'production');
      expect(productionDeps).toHaveLength(5);
      expect(productionDeps.some(dep => dep.name === 'express')).toBe(true);
      expect(productionDeps.some(dep => dep.name === 'lodash')).toBe(true);
      
      // Development dependencies
      const devDeps = analysis.projectDependencies.filter(dep => dep.type === 'development');
      expect(devDeps).toHaveLength(6);
      expect(devDeps.some(dep => dep.name === 'jest')).toBe(true);
      expect(devDeps.some(dep => dep.name === 'typescript')).toBe(true);
      
      // Peer dependencies
      const peerDeps = analysis.projectDependencies.filter(dep => dep.type === 'peer');
      expect(peerDeps).toHaveLength(2);
      expect(peerDeps.some(dep => dep.name === 'react')).toBe(true);
    });

    test('should detect file-level dependencies', async () => {
      const analysis = await analyzer.analyzeDependencies(testProjectPath);

      expect(analysis.fileDependencies).toBeDefined();
      expect(analysis.fileDependencies.length).toBeGreaterThan(0);
      
      // index.ts の依存関係をチェック
      const indexDeps = analysis.fileDependencies.find(dep => dep.file.includes('index.ts'));
      expect(indexDeps).toBeDefined();
      expect(indexDeps!.imports).toEqual(
        expect.arrayContaining(['express', './routes/user', './middleware/auth'])
      );
    });

    test('should track dependency usage across files', async () => {
      const analysis = await analyzer.analyzeDependencies(testProjectPath);

      const expressDep = analysis.projectDependencies.find(dep => dep.name === 'express');
      expect(expressDep).toBeDefined();
      expect(expressDep!.usage).toBeDefined();
      expect(expressDep!.usage.length).toBeGreaterThan(0);
      
      const usage = expressDep!.usage[0];
      expect(usage.file).toContain('index.ts');
      expect(usage.imports).toEqual(expect.arrayContaining(['express']));
    });

    test('should analyze version information from lock files', async () => {
      const analysis = await analyzer.analyzeDependencies(testProjectPath);

      const expressDep = analysis.projectDependencies.find(dep => dep.name === 'express');
      expect(expressDep).toBeDefined();
      expect(expressDep!.version).toBe('^4.18.0');
      expect(expressDep!.installedVersion).toBe('4.18.2'); // From yarn.lock
    });
  });

  describe('detectCyclicDependencies', () => {
    test('should detect potential cyclic dependencies', async () => {
      const cyclicDeps = await analyzer.detectCyclicDependencies(testProjectPath);

      expect(cyclicDeps).toBeDefined();
      expect(Array.isArray(cyclicDeps)).toBe(true);
      
      // UserService と DatabaseConnection の間の潜在的な循環依存
      const hasCyclicDep = cyclicDeps.some(dep => 
        dep.files.some(file => file.includes('userService')) &&
        dep.files.some(file => file.includes('database'))
      );
      
      // 循環依存の可能性があることを確認（コメントアウトされているが）
      expect(cyclicDeps.length).toBeGreaterThanOrEqual(0);
    });

    test('should categorize cyclic dependencies by severity', async () => {
      const cyclicDeps = await analyzer.detectCyclicDependencies(testProjectPath);

      if (cyclicDeps.length > 0) {
        cyclicDeps.forEach(dep => {
          expect(['error', 'warning', 'info']).toContain(dep.severity);
          expect(dep.suggestion).toBeDefined();
          expect(typeof dep.suggestion).toBe('string');
        });
      }
    });
  });

  describe('findUnusedDependencies', () => {
    test('should identify unused dependencies', async () => {
      const unusedDeps = await analyzer.findUnusedDependencies(testProjectPath);

      expect(unusedDeps).toBeDefined();
      expect(Array.isArray(unusedDeps)).toBe(true);
      
      // fsevents は使用されていないはず（macOS専用で実際のコードでは使われていない）
      expect(unusedDeps).toContain('fsevents');
    });

    test('should not flag used dependencies as unused', async () => {
      const unusedDeps = await analyzer.findUnusedDependencies(testProjectPath);

      // 実際に使用されているdependenciesは含まれないはず
      expect(unusedDeps).not.toContain('express');
      expect(unusedDeps).not.toContain('lodash');
      expect(unusedDeps).not.toContain('axios');
      expect(unusedDeps).not.toContain('uuid');
    });

    test('should handle devDependencies appropriately', async () => {
      const unusedDeps = await analyzer.findUnusedDependencies(testProjectPath);

      // devDependenciesは通常のコード分析では使用されていないように見えるが、
      // テストやビルドツールとして実際には必要
      // この判定は複雑なので、基本的な動作確認のみ
      expect(Array.isArray(unusedDeps)).toBe(true);
    });
  });

  describe('findMissingDependencies', () => {
    test('should detect missing dependencies', async () => {
      const missingDeps = await analyzer.findMissingDependencies(testProjectPath);

      expect(missingDeps).toBeDefined();
      expect(Array.isArray(missingDeps)).toBe(true);
      
      // jsonwebtoken と joi は使用されているがpackage.jsonにない
      expect(missingDeps).toContain('jsonwebtoken');
      expect(missingDeps).toContain('joi');
    });

    test('should not flag installed dependencies as missing', async () => {
      const missingDeps = await analyzer.findMissingDependencies(testProjectPath);

      // インストール済みの依存関係は含まれないはず
      expect(missingDeps).not.toContain('express');
      expect(missingDeps).not.toContain('lodash');
      expect(missingDeps).not.toContain('moment');
    });

    test('should handle TypeScript type dependencies', async () => {
      const missingDeps = await analyzer.findMissingDependencies(testProjectPath);

      // @types/* パッケージの扱いを確認
      // 実装によっては型定義の不足も検出する可能性がある
      expect(Array.isArray(missingDeps)).toBe(true);
    });
  });

  describe('analyzeVersionConstraints', () => {
    test('should analyze version constraint patterns', async () => {
      const constraints = await analyzer.analyzeVersionConstraints(testProjectPath);

      expect(constraints).toBeDefined();
      expect(Array.isArray(constraints)).toBe(true);
      
      if (constraints.length > 0) {
        constraints.forEach(constraint => {
          expect(constraint).toHaveProperty('name');
          expect(constraint).toHaveProperty('declared');
          expect(constraint).toHaveProperty('installed');
          expect(constraint).toHaveProperty('satisfies');
        });
      }
    });

    test('should detect version mismatches', async () => {
      const constraints = await analyzer.analyzeVersionConstraints(testProjectPath);

      // バージョン制約が満たされているかチェック
      const lodashConstraint = constraints.find(c => c.name === 'lodash');
      if (lodashConstraint) {
        expect(typeof lodashConstraint.satisfies).toBe('boolean');
      }
    });
  });

  describe('Error Handling', () => {
    test('should handle missing package.json gracefully', async () => {
      const emptyProjectPath = fs.mkdtempSync(path.join(os.tmpdir(), 'empty-project-'));
      
      try {
        const analysis = await analyzer.analyzeDependencies(emptyProjectPath);
        
        expect(analysis).toBeDefined();
        expect(analysis.projectDependencies).toHaveLength(0);
        expect(analysis.fileDependencies).toHaveLength(0);
      } finally {
        fs.rmSync(emptyProjectPath, { recursive: true, force: true });
      }
    });

    test('should handle corrupted package.json', async () => {
      const corruptedProjectPath = fs.mkdtempSync(path.join(os.tmpdir(), 'corrupted-project-'));
      
      try {
        fs.writeFileSync(path.join(corruptedProjectPath, 'package.json'), '{ invalid json');
        
        const analysis = await analyzer.analyzeDependencies(corruptedProjectPath);
        
        expect(analysis).toBeDefined();
        expect(analysis.projectDependencies).toHaveLength(0);
      } finally {
        fs.rmSync(corruptedProjectPath, { recursive: true, force: true });
      }
    });

    test('should handle non-existent project path', async () => {
      await expect(
        analyzer.analyzeDependencies('/non/existent/path')
      ).rejects.toThrow();
    });
  });

  describe('Performance', () => {
    test('should complete analysis within reasonable time', async () => {
      const startTime = Date.now();
      const analysis = await analyzer.analyzeDependencies(testProjectPath);
      const endTime = Date.now();

      expect(analysis).toBeDefined();
      expect(endTime - startTime).toBeLessThan(10000); // 10秒以内
    });

    test('should handle large projects efficiently', async () => {
      // 大量のファイルを作成
      const largeProjectPath = fs.mkdtempSync(path.join(os.tmpdir(), 'large-project-'));
      
      try {
        fs.writeFileSync(path.join(largeProjectPath, 'package.json'), JSON.stringify({
          name: 'large-project',
          dependencies: Object.fromEntries(
            Array.from({ length: 100 }, (_, i) => [`package-${i}`, `^1.0.0`])
          )
        }, null, 2));

        fs.mkdirSync(path.join(largeProjectPath, 'src'), { recursive: true });
        
        // 100個のファイルを作成
        for (let i = 0; i < 100; i++) {
          const fileContent = `import pkg${i} from 'package-${i}';\nexport const value${i} = pkg${i};`;
          fs.writeFileSync(path.join(largeProjectPath, `src/file${i}.ts`), fileContent);
        }

        const startTime = Date.now();
        const analysis = await analyzer.analyzeDependencies(largeProjectPath);
        const endTime = Date.now();

        expect(analysis.projectDependencies.length).toBeGreaterThan(50);
        expect(endTime - startTime).toBeLessThan(15000); // 15秒以内
      } finally {
        fs.rmSync(largeProjectPath, { recursive: true, force: true });
      }
    });
  });

  describe('Integration with Package Managers', () => {
    test('should detect package manager type', async () => {
      const packageManager = await analyzer.detectPackageManager(testProjectPath);
      
      expect(packageManager).toBeDefined();
      expect(['npm', 'yarn', 'pnpm', 'unknown']).toContain(packageManager);
      
      // yarn.lock があるので yarn を検出するはず
      expect(packageManager).toBe('yarn');
    });

    test('should handle multiple lock files', async () => {
      // package-lock.json も追加
      const packageLock = {
        name: 'test-project',
        version: '1.0.0',
        lockfileVersion: 2,
        requires: true,
        packages: {
          '': {
            name: 'test-project',
            version: '1.0.0'
          }
        }
      };

      fs.writeFileSync(path.join(testProjectPath, 'package-lock.json'), JSON.stringify(packageLock, null, 2));

      const packageManager = await analyzer.detectPackageManager(testProjectPath);
      
      // 複数のlock fileがある場合の優先順位をテスト
      expect(['npm', 'yarn']).toContain(packageManager);
    });
  });
});