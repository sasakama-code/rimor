{"file":"/Users/sasakama/Projects/Rimor/src/analyzers/structure-analysis/naming-analyzer.ts","mappings":"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","names":[],"sources":["/Users/sasakama/Projects/Rimor/src/analyzers/structure-analysis/naming-analyzer.ts"],"sourcesContent":["/**\n * NamingAnalyzer\n * Issue #65: 命名規則分析専用モジュール\n * \n * SOLID原則: 単一責任（命名規則分析のみ）\n * DRY原則: パターンマッチングロジックの共通化\n * KISS原則: シンプルな正規表現ベースの分析\n * YAGNI原則: 必要最小限の機能実装\n * Defensive Programming: 入力検証とエラーハンドリング\n */\n\nimport { \n  NamingConventions, \n  NamingPattern,\n  FileNamingConvention,\n  DirectoryNamingConvention,\n  VariableNamingConvention,\n  FunctionNamingConvention,\n  ClassNamingConvention\n} from '../types';\nimport * as fs from 'fs';\nimport * as glob from 'glob';\nimport * as path from 'path';\n\n/**\n * 命名規則を分析する専用クラス\n */\nexport class NamingAnalyzer {\n  /**\n   * プロジェクト全体の命名規則を分析\n   */\n  async analyzeNamingConventions(projectPath: string): Promise<NamingConventions> {\n    const files = this.getAllFiles(projectPath);\n    const codeContents = await this.readAllCodeFiles(files);\n    const fileNames = files.map(f => path.basename(f));\n    \n    // ファイル名の分析\n    const filePattern = this.analyzeFileNaming(fileNames);\n    \n    // 変数名の分析\n    const variablePatterns = this.analyzeVariableNaming(codeContents);\n    const variablePattern = this.getDominantPattern(variablePatterns);\n    \n    // 関数名の分析\n    const functionPatterns = this.analyzeFunctionNaming(codeContents);\n    const functionPattern = this.getDominantPattern(functionPatterns);\n    \n    // クラス名の分析\n    const classPatterns = this.analyzeClassNaming(codeContents);\n    const classPattern = this.getDominantPattern(classPatterns.patterns);\n    \n    // ディレクトリ名の分析（簡易実装）\n    const dirPattern = 'kebab-case' as NamingPattern;\n    \n    return {\n      files: {\n        pattern: filePattern,\n        confidence: 0.8,\n        examples: fileNames.slice(0, 3),\n        violations: []\n      },\n      directories: {\n        pattern: dirPattern,\n        confidence: 0.7,\n        examples: ['src', 'test', 'lib'],\n        violations: []\n      },\n      variables: {\n        pattern: variablePattern,\n        confidence: 0.85,\n        examples: variablePatterns[variablePattern]?.slice(0, 3) || [],\n        violations: []\n      },\n      functions: {\n        pattern: functionPattern,\n        confidence: 0.85,\n        examples: functionPatterns[functionPattern]?.slice(0, 3) || [],\n        violations: []\n      },\n      classes: {\n        pattern: classPattern,\n        confidence: 0.9,\n        examples: classPatterns.patterns[classPattern]?.slice(0, 3) || [],\n        violations: []\n      }\n    };\n  }\n  \n  /**\n   * ファイル名の命名パターンを分析\n   */\n  analyzeFileNaming(fileNames: string[]): NamingPattern {\n    const patterns = {\n      camelCase: fileNames.filter(name => /^[a-z][a-zA-Z0-9]*\\.[a-z]+$/.test(name)),\n      PascalCase: fileNames.filter(name => /^[A-Z][a-zA-Z0-9]*\\.[a-z]+$/.test(name)),\n      snake_case: fileNames.filter(name => /^[a-z][a-z0-9_]*\\.[a-z]+$/.test(name)),\n      'kebab-case': fileNames.filter(name => /^[a-z][a-z0-9-]*\\.[a-z]+$/.test(name)),\n      SCREAMING_SNAKE_CASE: fileNames.filter(name => /^[A-Z][A-Z0-9_]*\\.[a-z]+$/.test(name))\n    };\n    \n    return this.getDominantPattern(patterns);\n  }\n  \n  /**\n   * 変数名の命名パターンを分析\n   */\n  analyzeVariableNaming(code: string): Record<string, string[]> {\n    const patterns: Record<string, string[]> = {\n      camelCase: [],\n      PascalCase: [],\n      snake_case: [],\n      'kebab-case': [],\n      SCREAMING_SNAKE_CASE: []\n    };\n    \n    // const/let/var 変数宣言を抽出\n    const variableRegex = /(?:const|let|var)\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;\n    let match;\n    \n    while ((match = variableRegex.exec(code)) !== null) {\n      const varName = match[1];\n      \n      if (/^[a-z][a-zA-Z0-9]*$/.test(varName)) {\n        patterns.camelCase.push(varName);\n      } else if (/^[A-Z][a-zA-Z0-9]*$/.test(varName)) {\n        patterns.PascalCase.push(varName);\n      } else if (/^[a-z][a-z0-9_]*$/.test(varName)) {\n        patterns.snake_case.push(varName);\n      } else if (/^[A-Z][A-Z0-9_]*$/.test(varName) && varName.includes('_')) {\n        patterns.SCREAMING_SNAKE_CASE.push(varName);\n      }\n    }\n    \n    return patterns;\n  }\n  \n  /**\n   * 関数名の命名パターンを分析\n   */\n  analyzeFunctionNaming(code: string): Record<string, string[]> {\n    const patterns: Record<string, string[]> = {\n      camelCase: [],\n      PascalCase: [],\n      snake_case: [],\n      'kebab-case': [],\n      SCREAMING_SNAKE_CASE: []\n    };\n    \n    // function宣言とアロー関数を抽出\n    const functionRegex = /(?:function\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)|const\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\\([^)]*\\)|[a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=>)/g;\n    let match;\n    \n    while ((match = functionRegex.exec(code)) !== null) {\n      const funcName = match[1] || match[2];\n      \n      if (/^[a-z][a-zA-Z0-9]*$/.test(funcName)) {\n        patterns.camelCase.push(funcName);\n      } else if (/^[A-Z][a-zA-Z0-9]*$/.test(funcName)) {\n        patterns.PascalCase.push(funcName);\n      } else if (/^[a-z][a-z0-9_]*$/.test(funcName)) {\n        patterns.snake_case.push(funcName);\n      } else if (/^[A-Z][A-Z0-9_]*$/.test(funcName)) {\n        patterns.SCREAMING_SNAKE_CASE.push(funcName);\n      }\n    }\n    \n    return patterns;\n  }\n  \n  /**\n   * クラス名の命名パターンを分析\n   */\n  analyzeClassNaming(code: string): {\n    patterns: Record<string, string[]>;\n    interfaces: string[];\n    types: string[];\n  } {\n    const patterns: Record<string, string[]> = {\n      camelCase: [],\n      PascalCase: [],\n      snake_case: [],\n      'kebab-case': [],\n      SCREAMING_SNAKE_CASE: []\n    };\n    const interfaces: string[] = [];\n    const types: string[] = [];\n    \n    // クラス宣言を抽出\n    const classRegex = /class\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;\n    let match;\n    \n    while ((match = classRegex.exec(code)) !== null) {\n      const className = match[1];\n      \n      if (/^[a-z][a-zA-Z0-9]*$/.test(className)) {\n        patterns.camelCase.push(className);\n      } else if (/^[A-Z][a-zA-Z0-9]*$/.test(className)) {\n        patterns.PascalCase.push(className);\n      } else if (/^[a-z][a-z0-9_]*$/.test(className)) {\n        patterns.snake_case.push(className);\n      }\n    }\n    \n    // インターフェース宣言を抽出\n    const interfaceRegex = /interface\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;\n    while ((match = interfaceRegex.exec(code)) !== null) {\n      interfaces.push(match[1]);\n    }\n    \n    // 型エイリアス宣言を抽出\n    const typeRegex = /type\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;\n    while ((match = typeRegex.exec(code)) !== null) {\n      types.push(match[1]);\n    }\n    \n    return { patterns, interfaces, types };\n  }\n  \n  /**\n   * 最も使用頻度の高いパターンを特定\n   */\n  getDominantPattern(patterns: Record<string, string[]>): NamingPattern {\n    let maxCount = 0;\n    let dominantPattern: NamingPattern = 'mixed';\n    let tieCount = 0;\n    \n    for (const [pattern, items] of Object.entries(patterns)) {\n      if (items.length > maxCount) {\n        maxCount = items.length;\n        dominantPattern = pattern as NamingPattern;\n        tieCount = 1;\n      } else if (items.length === maxCount && items.length > 0) {\n        tieCount++;\n      }\n    }\n    \n    // 同数の場合はmixedを返す\n    if (tieCount > 1) {\n      return 'mixed';\n    }\n    \n    return dominantPattern;\n  }\n  \n  /**\n   * 命名規則の総合レポートを生成\n   */\n  generateNamingReport(conventions: NamingConventions): string {\n    const lines = [\n      '=== Naming Conventions Analysis ===',\n      '',\n      `Files: ${conventions.files.pattern} (${Math.round(conventions.files.confidence * 100)}% confidence)`,\n      `Directories: ${conventions.directories.pattern} (${Math.round(conventions.directories.confidence * 100)}% confidence)`,\n      `Variables: ${conventions.variables.pattern} (${Math.round(conventions.variables.confidence * 100)}% confidence)`,\n      `Functions: ${conventions.functions.pattern} (${Math.round(conventions.functions.confidence * 100)}% confidence)`,\n      `Classes: ${conventions.classes.pattern} (${Math.round(conventions.classes.confidence * 100)}% confidence)`,\n      '',\n      `Overall Consistency: ${Math.round(this.calculateOverallConsistency(conventions) * 100)}%`,\n      ''\n    ];\n    \n    // 例を追加\n    if (conventions.files.examples.length > 0) {\n      lines.push('File Examples:');\n      conventions.files.examples.forEach(ex => lines.push(`  - ${ex}`));\n      lines.push('');\n    }\n    \n    return lines.join('\\n');\n  }\n  \n  /**\n   * 全体的な一貫性を計算\n   */\n  private calculateOverallConsistency(conventions: NamingConventions): number {\n    const confidences = [\n      conventions.files.confidence,\n      conventions.directories.confidence,\n      conventions.variables.confidence,\n      conventions.functions.confidence,\n      conventions.classes.confidence\n    ];\n    \n    return confidences.reduce((sum, conf) => sum + conf, 0) / confidences.length;\n  }\n  \n  /**\n   * すべてのコードファイルを取得\n   */\n  private getAllFiles(projectPath: string): string[] {\n    const pattern = path.join(projectPath, '**/*.{js,jsx,ts,tsx}');\n    return glob.sync(pattern, {\n      ignore: ['**/node_modules/**', '**/dist/**', '**/build/**']\n    });\n  }\n  \n  /**\n   * すべてのコードファイルを読み込み\n   */\n  private async readAllCodeFiles(files: string[]): Promise<string> {\n    const contents: string[] = [];\n    \n    for (const file of files) {\n      try {\n        const content = fs.readFileSync(file, 'utf-8');\n        contents.push(content);\n      } catch (error) {\n        // ファイル読み込みエラーは無視\n      }\n    }\n    \n    return contents.join('\\n');\n  }\n  \n  /**\n   * 一貫性スコアを計算\n   */\n  private calculateConsistency(patterns: (NamingPattern | undefined)[]): number {\n    const validPatterns = patterns.filter(p => p && p !== 'mixed');\n    if (validPatterns.length === 0) return 0;\n    \n    const patternCounts = new Map<string, number>();\n    validPatterns.forEach(pattern => {\n      if (pattern) {\n        patternCounts.set(pattern, (patternCounts.get(pattern) || 0) + 1);\n      }\n    });\n    \n    const maxCount = Math.max(...patternCounts.values());\n    return maxCount / validPatterns.length;\n  }\n  \n}"],"version":3}