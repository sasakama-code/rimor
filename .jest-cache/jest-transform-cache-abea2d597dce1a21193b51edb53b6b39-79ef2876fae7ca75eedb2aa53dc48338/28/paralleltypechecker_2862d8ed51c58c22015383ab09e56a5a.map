{"file":"/Users/sasakama/Projects/Rimor/src/security/checker/parallel-type-checker.ts","mappings":"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","names":[],"sources":["/Users/sasakama/Projects/Rimor/src/security/checker/parallel-type-checker.ts"],"sourcesContent":["/**\n * 並列型チェッカー\n * arXiv:2504.18529v2 Section 6.1 \"Modular Analysis\" の実装\n * \n * メソッド単位での独立した型チェックを並列実行し、\n * 論文で報告されている2.93X–22.9Xの高速化を実現\n */\n\nimport * as os from 'os';\nimport { Worker } from 'worker_threads';\nimport { EventEmitter } from 'events';\nimport {\n  TestMethod,\n  TaintLevel,\n  TaintSource\n} from '../../core/types';\nimport {\n  MethodAnalysisResult,\n  SecurityIssue,\n  TypeInferenceResult\n} from '../types/flow-types';\nimport {\n  TaintQualifier,\n  QualifiedType,\n  TypeCheckResult,\n  TypeQualifierError,\n  SubtypingChecker\n} from '../types/checker-framework-types';\nimport { SearchBasedInferenceEngine } from '../analysis/search-based-inference';\nimport { LocalInferenceOptimizer } from '../inference/local-inference-optimizer';\n\n/**\n * 並列型チェックの設定\n */\nexport interface ParallelTypeCheckConfig {\n  /** ワーカースレッド数（デフォルト: CPUコア数） */\n  workerCount?: number;\n  /** メソッドあたりの最大解析時間（ミリ秒） */\n  methodTimeout?: number;\n  /** バッチサイズ（一度に処理するメソッド数） */\n  batchSize?: number;\n  /** キャッシュを有効にするか */\n  enableCache?: boolean;\n  /** デバッグモード */\n  debug?: boolean;\n}\n\n/**\n * ワーカータスク\n */\ninterface WorkerTask {\n  id: string;\n  method: TestMethod;\n  dependencies: Array<[string, QualifiedType<unknown>]>;\n}\n\n/**\n * ワーカー結果\n */\ninterface WorkerResult {\n  id: string;\n  success: boolean;\n  result?: MethodTypeCheckResult;\n  error?: Error;\n  executionTime: number;\n}\n\n/**\n * メソッド型チェック結果\n */\nexport interface MethodTypeCheckResult {\n  method: TestMethod;\n  typeCheckResult: TypeCheckResult;\n  inferredTypes: Map<string, QualifiedType<unknown>>;\n  securityIssues: SecurityIssue[];\n  executionTime: number;\n}\n\n/**\n * 並列型チェッカー\n */\nexport class ParallelTypeChecker extends EventEmitter {\n  private config: Required<ParallelTypeCheckConfig>;\n  private workers: Set<Worker> = new Set();\n  private activeWorkers = 0;\n  private workerStates: Map<Worker, boolean> = new Map(); // true = busy, false = idle\n  private results: Map<string, MethodTypeCheckResult> = new Map();\n  private currentTasks: Map<string, WorkerTask> = new Map(); // Store current tasks\n  private taskCallbacks: Map<string, { resolve: Function; reject: Function; timeout?: NodeJS.Timeout }> = new Map();\n  private inferenceEngine: SearchBasedInferenceEngine;\n  private localOptimizer: LocalInferenceOptimizer;\n\n  constructor(config?: ParallelTypeCheckConfig) {\n    super();\n    this.config = {\n      workerCount: config?.workerCount || os.cpus().length,\n      methodTimeout: config?.methodTimeout || 30000,\n      batchSize: config?.batchSize || 10,\n      enableCache: config?.enableCache !== false,\n      debug: config?.debug || false\n    };\n    \n    this.inferenceEngine = new SearchBasedInferenceEngine();\n    this.localOptimizer = new LocalInferenceOptimizer();\n    \n    this.initializeWorkers();\n  }\n\n  /**\n   * ワーカーの初期化\n   */\n  private initializeWorkers(): void {\n    // ワーカーファイルが存在しない可能性があるため、\n    // ワーカー初期化をスキップしてローカル実行にフォールバック\n    if (this.config.debug) {\n      console.log('Skipping worker initialization - will use local execution');\n    }\n    // ワーカーは作成しない（すべてローカルで実行）\n  }\n\n  /**\n   * メソッドの並列型チェック\n   */\n  async checkMethodsInParallel(methods: TestMethod[]): Promise<Map<string, MethodTypeCheckResult>> {\n    this.results.clear();\n    \n    // メソッドの依存関係を解析\n    const dependencies = await this.analyzeDependencies(methods);\n    \n    // タスクを作成\n    const tasks = methods.map(method => ({\n      id: method.name,\n      method,\n      dependencies: Array.from(dependencies.get(method.name) || new Map())\n    }));\n    \n    // バッチ処理\n    const batches = this.createBatches(tasks, this.config.batchSize);\n    \n    for (const batch of batches) {\n      await this.processBatch(batch);\n    }\n    \n    return this.results;\n  }\n\n  /**\n   * 依存関係の解析\n   */\n  private async analyzeDependencies(methods: TestMethod[]): Promise<Map<string, Map<string, QualifiedType<unknown>>>> {\n    const dependencies = new Map<string, Map<string, QualifiedType<unknown>>>();\n    \n    // 簡易実装：メソッド間の依存関係を検出\n    for (const method of methods) {\n      const deps = new Map<string, QualifiedType<unknown>>();\n      \n      // インポートや共有変数の検出\n      const imports = this.extractImports(method.content || '');\n      for (const imp of imports) {\n        // 既知の型情報から依存関係を解決\n        if (this.results.has(imp)) {\n          const result = this.results.get(imp)!;\n          result.inferredTypes.forEach((type, name) => {\n            deps.set(`${imp}.${name}`, type);\n          });\n        }\n      }\n      \n      dependencies.set(method.name, deps);\n    }\n    \n    return dependencies;\n  }\n\n  /**\n   * バッチの作成\n   */\n  private createBatches<T>(items: T[], batchSize: number): T[][] {\n    const batches: T[][] = [];\n    for (let i = 0; i < items.length; i += batchSize) {\n      batches.push(items.slice(i, i + batchSize));\n    }\n    return batches;\n  }\n\n  /**\n   * バッチの処理\n   */\n  private async processBatch(batch: WorkerTask[]): Promise<void> {\n    const promises = batch.map(task => this.processTask(task));\n    await Promise.all(promises);\n  }\n\n  /**\n   * タスクの処理\n   */\n  private async processTask(task: WorkerTask): Promise<void> {\n    return new Promise((resolve, reject) => {\n      // タスクの依存関係を確実に配列として設定\n      if (!task.dependencies || !Array.isArray(task.dependencies)) {\n        task.dependencies = [];\n      }\n      \n      // ワーカーが利用できない場合はシングルスレッドで実行\n      if (this.workers.size === 0) {\n        this.executeTaskLocally(task).then(resolve).catch(reject);\n        return;\n      }\n      \n      // タスクを保存\n      this.currentTasks.set(task.id, task);\n      this.taskCallbacks.set(task.id, { resolve, reject });\n      \n      const tryAssignWorker = () => {\n        // 利用可能なワーカーを探す\n        let availableWorker: Worker | null = null;\n        for (const worker of this.workers) {\n          if (!this.workerStates.get(worker)) {\n            availableWorker = worker;\n            break;\n          }\n        }\n        \n        if (availableWorker) {\n          this.workerStates.set(availableWorker, true); // Mark as busy\n          this.activeWorkers++;\n          \n          // タイムアウト設定\n          const timeout = setTimeout(() => {\n            this.workerStates.set(availableWorker!, false); // Mark as idle\n            this.activeWorkers--;\n            \n            const callback = this.taskCallbacks.get(task.id);\n            if (callback) {\n              callback.reject(new Error(`Task ${task.id} timed out`));\n              this.taskCallbacks.delete(task.id);\n              this.currentTasks.delete(task.id);\n            }\n          }, this.config.methodTimeout);\n          \n          // タイムアウトをコールバックに保存\n          const callback = this.taskCallbacks.get(task.id);\n          if (callback) {\n            callback.timeout = timeout;\n          }\n          \n          availableWorker.postMessage(task);\n        } else {\n          // すべてのワーカーが使用中の場合、少し待ってから再試行\n          setTimeout(tryAssignWorker, 100);\n        }\n      };\n      \n      tryAssignWorker();\n    });\n  }\n\n  /**\n   * タスクをローカルで実行（ワーカーが利用できない場合）\n   */\n  private async executeTaskLocally(task: WorkerTask): Promise<void> {\n    const startTime = Date.now();\n    \n    try {\n      // 簡単な型チェック結果を生成（実際の型チェックロジックは簡略化）\n      const result: MethodTypeCheckResult = {\n        method: task.method,\n        typeCheckResult: {\n          success: true,\n          errors: [],\n          warnings: []\n        },\n        inferredTypes: new Map(),\n        securityIssues: [],\n        executionTime: Date.now() - startTime\n      };\n      \n      // 結果を保存\n      this.results.set(task.id, result);\n      \n      // 結果イベントを発行\n      this.emit('methodCompleted', {\n        methodName: task.method.name,\n        success: true,\n        executionTime: result.executionTime\n      });\n    } catch (error) {\n      const errorResult: MethodTypeCheckResult = {\n        method: task.method,\n        typeCheckResult: {\n          success: false,\n          errors: [new TypeQualifierError(\n            error instanceof Error ? error.message : 'Unknown error',\n            '@Untainted',\n            '@Tainted'\n          )],\n          warnings: []\n        },\n        inferredTypes: new Map(),\n        securityIssues: [],\n        executionTime: Date.now() - startTime\n      };\n      \n      this.results.set(task.id, errorResult);\n      \n      this.emit('methodCompleted', {\n        methodName: task.method.name,\n        success: false,\n        executionTime: errorResult.executionTime\n      });\n    }\n  }\n\n  /**\n   * ワーカー結果の処理\n   */\n  private handleWorkerResult(result: any, worker: Worker): void {\n    // ワーカーのアイドル状態に戻す\n    this.workerStates.set(worker, false);\n    this.activeWorkers--;\n    \n    // タスクコールバックを取得\n    const callback = this.taskCallbacks.get(result.id);\n    if (!callback) {\n      if (this.config.debug) {\n        console.warn(`No callback found for task ${result.id}`);\n      }\n      return;\n    }\n    \n    // タイムアウトをクリア\n    if (callback.timeout) {\n      clearTimeout(callback.timeout);\n    }\n    \n    // タスクを見つける（メソッド情報を取得するため）\n    const task = this.currentTasks.get(result.id);\n    if (!task) {\n      console.error(`Task not found for result ${result.id}`);\n      callback.reject(new Error(`Task not found for result ${result.id}`));\n      this.taskCallbacks.delete(result.id);\n      this.currentTasks.delete(result.id);\n      return;\n    }\n    \n    // ワーカーから返されるのはTypeCheckWorkerResult型\n    // それをMethodTypeCheckResultに変換する必要がある\n    if (result.success && result.result) {\n      // MethodTypeCheckResultを構築\n      const methodResult: MethodTypeCheckResult = {\n        method: task.method,\n        typeCheckResult: {\n          success: result.success,\n          errors: [],\n          warnings: result.result.warnings || []\n        },\n        inferredTypes: result.result.inferredTypes || new Map(),\n        securityIssues: result.result.securityIssues || [],\n        executionTime: result.executionTime\n      };\n      \n      // エラーがある場合は追加\n      if (result.result.violations && result.result.violations.length > 0) {\n        methodResult.typeCheckResult.success = false;\n        methodResult.typeCheckResult.errors = result.result.violations.map((v: any) => \n          new TypeQualifierError(v.description || 'Type violation', '@Untainted', '@Tainted')\n        );\n      }\n      \n      this.results.set(result.id, methodResult);\n      \n      if (this.config.debug) {\n        console.log(`✓ Type checked ${result.id} in ${result.executionTime}ms`);\n      }\n      \n      // 成功を通知\n      callback.resolve();\n    } else {\n      if (this.config.debug) {\n        console.error(`✗ Type check failed for ${result.id}: ${result.error}`);\n      }\n      callback.reject(new Error(result.error || `Type check failed for ${result.id}`));\n    }\n    \n    // クリーンアップ\n    this.taskCallbacks.delete(result.id);\n    this.currentTasks.delete(result.id);\n  }\n\n  /**\n   * インポートの抽出\n   */\n  private extractImports(content: string): string[] {\n    const imports: string[] = [];\n    const importRegex = /import\\s+.*?from\\s+['\"](.+?)['\"]/g;\n    let match;\n    \n    while ((match = importRegex.exec(content)) !== null) {\n      imports.push(match[1]);\n    }\n    \n    return imports;\n  }\n\n  /**\n   * 実際の型チェック処理（ワーカー内で実行）\n   */\n  async performTypeCheck(task: WorkerTask): Promise<MethodTypeCheckResult> {\n    const startTime = Date.now();\n    const errors: TypeQualifierError[] = [];\n    const warnings: Array<{ message: string; location?: { file: string; line: number; column: number } }> = [];\n    const inferredTypes = new Map<string, QualifiedType<unknown>>();\n    const securityIssues: SecurityIssue[] = [];\n    \n    try {\n      // ローカル変数の最適化\n      const localAnalysis = await this.localOptimizer.analyzeLocalVariables(\n        task.method.content || '',\n        task.method.name || 'anonymous'\n      );\n      \n      // 推論エンジンによる型推論\n      const inferenceState = await this.inferenceEngine.inferTypes(\n        task.method.content || '',\n        task.method.filePath || ''\n      );\n      \n      // 型チェック\n      inferenceState.typeMap.forEach((qualifier, variable) => {\n        // TaintQualifierをQualifiedTypeに変換\n        const qualifiedType: QualifiedType<unknown> = qualifier === '@Tainted' \n          ? { __brand: '@Tainted', __value: variable, __source: 'inferred', __confidence: 1.0 } as QualifiedType<unknown>\n          : qualifier === '@Untainted'\n          ? { __brand: '@Untainted', __value: variable } as QualifiedType<unknown>\n          : { __brand: '@PolyTaint', __value: variable, __parameterIndices: [], __propagationRule: 'any' } as QualifiedType<unknown>;\n        \n        inferredTypes.set(variable, qualifiedType);\n        \n        // 依存関係の型との整合性チェック\n        const depsMap = new Map(task.dependencies);\n        const depType = depsMap.get(variable);\n        if (depType && !SubtypingChecker.isAssignmentSafe(depType, qualifiedType)) {\n          errors.push(new TypeQualifierError(\n            `Type mismatch for ${variable}`,\n            depType.__brand,\n            qualifiedType.__brand,\n            {\n              file: task.method.filePath || '',\n              line: 0,\n              column: 0\n            }\n          ));\n        }\n      });\n      \n      // セキュリティ問題の検出\n      if (localAnalysis.escapingVariables.length > 0) {\n        localAnalysis.escapingVariables.forEach(variable => {\n          const qualifiedType = inferredTypes.get(variable);\n          if (qualifiedType && qualifiedType.__brand === '@Tainted') {\n            securityIssues.push({\n              id: `escape-${variable}`,\n              type: 'unsafe-taint-flow',\n              severity: 'error',\n              message: `Tainted variable ${variable} escapes method scope`,\n              location: {\n                file: task.method.filePath || '',\n                line: 0,\n                column: 0\n              }\n            });\n          }\n        });\n      }\n      \n    } catch (error) {\n      errors.push(new TypeQualifierError(\n        error instanceof Error ? error.message : 'Unknown error',\n        '@Tainted',\n        '@Untainted'\n      ));\n    }\n    \n    return {\n      method: task.method,\n      typeCheckResult: {\n        success: errors.length === 0,\n        errors,\n        warnings\n      },\n      inferredTypes,\n      securityIssues,\n      executionTime: Date.now() - startTime\n    };\n  }\n\n  /**\n   * クリーンアップ\n   */\n  async cleanup(): Promise<void> {\n    // 未処理のタスクをキャンセル\n    for (const [taskId, callback] of this.taskCallbacks) {\n      if (callback.timeout) {\n        clearTimeout(callback.timeout);\n      }\n      callback.reject(new Error('Worker pool is shutting down'));\n    }\n    this.taskCallbacks.clear();\n    this.currentTasks.clear();\n    \n    // ワーカーの終了\n    const terminatePromises = Array.from(this.workers).map(worker => {\n      return worker.terminate().catch(err => {\n        if (this.config.debug) {\n          console.warn('Failed to terminate worker:', err);\n        }\n      });\n    });\n    \n    await Promise.all(terminatePromises);\n    this.workers.clear();\n    this.workerStates.clear();\n    this.results.clear();\n    this.activeWorkers = 0;\n  }\n\n  /**\n   * 統計情報の取得\n   */\n  getStatistics(): {\n    totalMethods: number;\n    successfulChecks: number;\n    failedChecks: number;\n    averageExecutionTime: number;\n    speedup: number;\n  } {\n    const results = Array.from(this.results.values());\n    const successfulChecks = results.filter(r => r.typeCheckResult.success).length;\n    const totalExecutionTime = results.reduce((sum, r) => sum + r.executionTime, 0);\n    const averageExecutionTime = results.length > 0 ? totalExecutionTime / results.length : 0;\n    \n    // スピードアップの計算（シーケンシャル実行時間との比較）\n    const sequentialTime = totalExecutionTime;\n    const parallelTime = results.length > 0 ? Math.max(...results.map(r => r.executionTime)) : 0;\n    const speedup = parallelTime > 0 ? sequentialTime / parallelTime : 1;\n    \n    return {\n      totalMethods: results.length,\n      successfulChecks,\n      failedChecks: results.length - successfulChecks,\n      averageExecutionTime,\n      speedup\n    };\n  }\n}\n\n/**\n * 並列型チェッカーのファクトリ関数\n */\nexport function createParallelTypeChecker(config?: ParallelTypeCheckConfig): ParallelTypeChecker {\n  return new ParallelTypeChecker(config);\n}\n\n/**\n * 型チェック結果の集約\n */\nexport class TypeCheckResultAggregator {\n  /**\n   * 複数の型チェック結果を集約\n   */\n  static aggregate(results: MethodTypeCheckResult[]): {\n    overallSuccess: boolean;\n    totalErrors: number;\n    totalWarnings: number;\n    criticalIssues: SecurityIssue[];\n    typeStatistics: Map<TaintQualifier, number>;\n  } {\n    let totalErrors = 0;\n    let totalWarnings = 0;\n    const criticalIssues: SecurityIssue[] = [];\n    const typeStatistics = new Map<TaintQualifier, number>();\n    \n    for (const result of results) {\n      totalErrors += result.typeCheckResult.errors.length;\n      totalWarnings += result.typeCheckResult.warnings.length;\n      \n      // クリティカルな問題を収集\n      criticalIssues.push(...result.securityIssues.filter(\n        issue => issue.severity === 'critical' || issue.severity === 'error'\n      ));\n      \n      // 型統計の収集\n      result.inferredTypes.forEach(type => {\n        const qualifier = type.__brand;\n        typeStatistics.set(qualifier, (typeStatistics.get(qualifier) || 0) + 1);\n      });\n    }\n    \n    return {\n      overallSuccess: totalErrors === 0,\n      totalErrors,\n      totalWarnings,\n      criticalIssues,\n      typeStatistics\n    };\n  }\n}"],"version":3}