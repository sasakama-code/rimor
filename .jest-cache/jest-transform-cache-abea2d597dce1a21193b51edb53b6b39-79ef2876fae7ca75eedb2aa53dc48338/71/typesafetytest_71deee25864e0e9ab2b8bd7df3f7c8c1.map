{"file":"/Users/sasakama/Projects/Rimor/test/core/types/type-safety.test.ts","mappings":"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","names":[],"sources":["/Users/sasakama/Projects/Rimor/test/core/types/type-safety.test.ts"],"sourcesContent":["import { describe, it, expect } from '@jest/globals';\nimport * as ts from 'typescript';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\ndescribe('Type Safety Verification', () => {\n  const createProgram = (files: { [fileName: string]: string }) => {\n    const options: ts.CompilerOptions = {\n      strict: true,\n      noImplicitAny: true,\n      strictNullChecks: true,\n      strictFunctionTypes: true,\n      strictBindCallApply: true,\n      strictPropertyInitialization: true,\n      noImplicitThis: true,\n      alwaysStrict: true,\n      esModuleInterop: true,\n      skipLibCheck: true,\n      target: ts.ScriptTarget.ES2020,\n      module: ts.ModuleKind.CommonJS,\n      moduleResolution: ts.ModuleResolutionKind.NodeJs,\n      noResolve: true\n    };\n\n    const host = ts.createCompilerHost(options);\n    const originalGetSourceFile = host.getSourceFile;\n    const originalFileExists = host.fileExists;\n    const originalReadFile = host.readFile;\n    \n    host.getSourceFile = (fileName, languageVersion, onError, shouldCreateNewSourceFile) => {\n      // Normalize the file name\n      const normalizedName = fileName.replace(/\\\\/g, '/');\n      const baseName = path.basename(normalizedName);\n      \n      if (files[baseName] !== undefined) {\n        return ts.createSourceFile(fileName, files[baseName], languageVersion, true);\n      }\n      if (files[normalizedName] !== undefined) {\n        return ts.createSourceFile(fileName, files[normalizedName], languageVersion, true);\n      }\n      // For relative imports like './types', check 'types.ts'\n      if (normalizedName.endsWith('/types')) {\n        const typesFile = files['types.ts'];\n        if (typesFile !== undefined) {\n          return ts.createSourceFile(fileName, typesFile, languageVersion, true);\n        }\n      }\n      return originalGetSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile);\n    };\n\n    host.fileExists = (fileName: string): boolean => {\n      const normalizedName = fileName.replace(/\\\\/g, '/');\n      const baseName = path.basename(normalizedName);\n      return files[baseName] !== undefined || \n             files[normalizedName] !== undefined ||\n             (normalizedName.endsWith('/types') && files['types.ts'] !== undefined) ||\n             originalFileExists(fileName);\n    };\n\n    host.readFile = (fileName: string): string | undefined => {\n      const normalizedName = fileName.replace(/\\\\/g, '/');\n      const baseName = path.basename(normalizedName);\n      if (files[baseName] !== undefined) return files[baseName];\n      if (files[normalizedName] !== undefined) return files[normalizedName];\n      if (normalizedName.endsWith('/types') && files['types.ts'] !== undefined) {\n        return files['types.ts'];\n      }\n      return originalReadFile(fileName);\n    };\n\n    const program = ts.createProgram(Object.keys(files), options, host);\n    return program;\n  };\n\n  const getDiagnostics = (program: ts.Program): ts.Diagnostic[] => {\n    const diagnostics = [\n      ...program.getSemanticDiagnostics(),\n      ...program.getSyntacticDiagnostics(),\n      ...program.getDeclarationDiagnostics()\n    ];\n    return diagnostics;\n  };\n\n  describe('Strict Mode Compilation', () => {\n    it('should compile without any type in core types', () => {\n      const testFile = `\n        import { PackageJsonConfig, ASTNode, ProjectContext } from './types';\n        \n        // Test that types don't use 'any'\n        const pkg: PackageJsonConfig = {\n          name: 'test',\n          version: '1.0.0',\n          dependencies: { 'typescript': '^5.0.0' }\n        };\n        \n        const ast: ASTNode = {\n          type: 'Function',\n          startPosition: { line: 1, column: 0 },\n          endPosition: { line: 5, column: 1 },\n          children: []\n        };\n        \n        const context: ProjectContext = {\n          rootPath: '/project',\n          language: 'typescript',\n          packageJson: pkg, // Should be typed, not any\n          ast: ast // Should be typed, not any\n        };\n      `;\n\n      const files = {\n        'test.ts': testFile,\n        'types.ts': `\n          export interface PackageJsonConfig {\n            name: string;\n            version: string;\n            description?: string;\n            main?: string;\n            scripts?: Record<string, string>;\n            dependencies?: Record<string, string>;\n            devDependencies?: Record<string, string>;\n            peerDependencies?: Record<string, string>;\n            optionalDependencies?: Record<string, string>;\n            engines?: Record<string, string>;\n            repository?: {\n              type: string;\n              url: string;\n            };\n            keywords?: string[];\n            author?: string | {\n              name: string;\n              email?: string;\n              url?: string;\n            };\n            license?: string;\n            bugs?: {\n              url?: string;\n              email?: string;\n            };\n            homepage?: string;\n            private?: boolean;\n          }\n          \n          export interface Position {\n            line: number;\n            column: number;\n            offset?: number;\n          }\n          \n          export interface ASTNode {\n            type: string;\n            startPosition: Position;\n            endPosition: Position;\n            children?: ASTNode[];\n            value?: string | number | boolean;\n            name?: string;\n            params?: ASTNode[];\n            body?: ASTNode | ASTNode[];\n            properties?: Record<string, unknown>;\n          }\n          \n          export interface ProjectContext {\n            rootPath?: string;\n            projectPath?: string;\n            language?: 'javascript' | 'typescript' | 'python' | 'java' | 'other';\n            testFramework?: string;\n            framework?: string;\n            packageJson?: PackageJsonConfig; // Typed, not any\n            tsConfig?: TSConfig; // Typed, not any\n            ast?: ASTNode; // Typed, not any\n            dependencies?: string[];\n            configuration?: Record<string, unknown>; // unknown instead of any\n            customConfig?: Record<string, unknown>; // unknown instead of any\n            filePatterns?: {\n              test: string[];\n              source: string[];\n              ignore: string[];\n            };\n          }\n          \n          export interface TSConfig {\n            compilerOptions?: {\n              target?: string;\n              module?: string;\n              lib?: string[];\n              outDir?: string;\n              rootDir?: string;\n              strict?: boolean;\n              esModuleInterop?: boolean;\n              skipLibCheck?: boolean;\n              forceConsistentCasingInFileNames?: boolean;\n              declaration?: boolean;\n              declarationMap?: boolean;\n              sourceMap?: boolean;\n              noImplicitAny?: boolean;\n              strictNullChecks?: boolean;\n              strictFunctionTypes?: boolean;\n              strictBindCallApply?: boolean;\n              strictPropertyInitialization?: boolean;\n              noImplicitThis?: boolean;\n              alwaysStrict?: boolean;\n              [key: string]: unknown;\n            };\n            include?: string[];\n            exclude?: string[];\n            files?: string[];\n            extends?: string;\n            references?: Array<{ path: string }>;\n          }\n        `\n      };\n\n      const program = createProgram(files);\n      const diagnostics = getDiagnostics(program);\n      \n      const errors = diagnostics.filter(d => d.category === ts.DiagnosticCategory.Error);\n      expect(errors).toHaveLength(0);\n    });\n\n    it('should enforce type safety for plugin interfaces', () => {\n      const testFile = `\n        import { IPlugin, ITestQualityPlugin } from './types';\n        \n        // Test that plugin interfaces are properly typed\n        const simplePlugin: IPlugin = {\n          name: 'test-plugin',\n          analyze: async (filePath: string) => {\n            return []; // Should return Issue[]\n          }\n        };\n        \n        const qualityPlugin: ITestQualityPlugin = {\n          id: 'quality-plugin',\n          name: 'Quality Plugin',\n          version: '1.0.0',\n          type: 'core',\n          isApplicable: (context) => true,\n          detectPatterns: async (testFile) => [],\n          evaluateQuality: (patterns) => ({\n            overall: 0.8,\n            dimensions: {},\n            confidence: 0.9\n          }),\n          suggestImprovements: (evaluation) => []\n        };\n      `;\n\n      const files = {\n        'test.ts': testFile,\n        'types.ts': `\n          export interface Issue {\n            type: string;\n            severity: 'info' | 'low' | 'medium' | 'high' | 'critical';\n            message: string;\n            line?: number;\n            endLine?: number;\n            column?: number;\n            endColumn?: number;\n            file?: string;\n            recommendation?: string;\n            codeSnippet?: string;\n            plugin?: string;\n          }\n          \n          export interface IPlugin {\n            name: string;\n            analyze(filePath: string): Promise<Issue[]>;\n          }\n          \n          export interface ITestQualityPlugin {\n            id: string;\n            name: string;\n            version: string;\n            type: 'core' | 'framework' | 'pattern' | 'domain';\n            isApplicable(context: ProjectContext): boolean;\n            detectPatterns(testFile: TestFile): Promise<DetectionResult[]>;\n            evaluateQuality(patterns: DetectionResult[]): QualityScore;\n            suggestImprovements(evaluation: QualityScore): Improvement[];\n            autoFix?(testFile: TestFile, improvements: Improvement[]): Promise<FixResult>;\n            learn?(feedback: Feedback): void;\n          }\n          \n          export interface ProjectContext {\n            rootPath?: string;\n          }\n          \n          export interface TestFile {\n            path: string;\n            content: string;\n          }\n          \n          export interface DetectionResult {\n            confidence: number;\n          }\n          \n          export interface QualityScore {\n            overall: number;\n            dimensions: Record<string, number>;\n            confidence: number;\n          }\n          \n          export interface Improvement {\n            id: string;\n            type: string;\n            priority: string;\n            title: string;\n            description: string;\n          }\n          \n          export interface FixResult {\n            success: boolean;\n            modifiedFiles: string[];\n          }\n          \n          export interface Feedback {\n            helpful: boolean;\n            comment?: string;\n          }\n        `\n      };\n\n      const program = createProgram(files);\n      const diagnostics = getDiagnostics(program);\n      \n      const errors = diagnostics.filter(d => d.category === ts.DiagnosticCategory.Error);\n      expect(errors).toHaveLength(0);\n    });\n\n    it('should not allow any type in new type definitions', () => {\n      const testFile = `\n        import { StrictTypedInterface } from './types';\n        \n        // This should fail if any is used\n        const strictObj: StrictTypedInterface = {\n          data: { key: 'value' }, // Should be properly typed\n          metadata: { timestamp: Date.now() }, // Should be properly typed\n          config: { enabled: true } // Should be properly typed\n        };\n      `;\n\n      const filesWithAny = {\n        'test.ts': testFile,\n        'types.ts': `\n          export interface StrictTypedInterface {\n            data: any; // This should cause an error in strict mode\n            metadata: any; // This should cause an error in strict mode\n            config: any; // This should cause an error in strict mode\n          }\n        `\n      };\n\n      const filesWithoutAny = {\n        'test.ts': testFile,\n        'types.ts': `\n          export interface StrictTypedInterface {\n            data: Record<string, unknown>;\n            metadata: Record<string, unknown>;\n            config: Record<string, unknown>;\n          }\n        `\n      };\n\n      // Test with any - should have errors\n      const programWithAny = createProgram(filesWithAny);\n      const diagnosticsWithAny = getDiagnostics(programWithAny);\n      const errorsWithAny = diagnosticsWithAny.filter(\n        d => d.category === ts.DiagnosticCategory.Error && \n        d.code === 7006 // Parameter implicitly has an 'any' type\n      );\n      \n      // Test without any - should have no errors\n      const programWithoutAny = createProgram(filesWithoutAny);\n      const diagnosticsWithoutAny = getDiagnostics(programWithoutAny);\n      const errorsWithoutAny = diagnosticsWithoutAny.filter(\n        d => d.category === ts.DiagnosticCategory.Error\n      );\n      \n      expect(errorsWithoutAny).toHaveLength(0);\n    });\n  });\n\n  describe('Type Definition Structure', () => {\n    it('should have proper separation of concerns', () => {\n      // Test that types are properly organized\n      const baseTypes = ['Issue', 'Location', 'Position'];\n      const pluginTypes = ['IPlugin', 'ITestQualityPlugin', 'PluginResult'];\n      const analysisTypes = ['DetectionResult', 'QualityScore', 'Evidence'];\n      const domainTypes = ['DomainDictionary', 'DomainTerm', 'BusinessRule'];\n      \n      // Each group should be in its own module\n      const expectedStructure = {\n        'base-types.ts': baseTypes,\n        'plugin-interface.ts': pluginTypes,\n        'analysis-result.ts': analysisTypes,\n        'domain-dictionary.ts': domainTypes\n      };\n      \n      // This test verifies the expected structure exists\n      // In actual implementation, we'll verify the files exist and contain the expected exports\n      expect(expectedStructure).toBeDefined();\n    });\n  });\n\n  describe('Circular Dependency Check', () => {\n    it('should not have circular dependencies between type modules', () => {\n      // This test would verify that there are no circular imports\n      // between the split type files\n      \n      const imports = {\n        'base-types.ts': [],\n        'plugin-interface.ts': ['base-types'],\n        'analysis-result.ts': ['base-types'],\n        'quality-score.ts': ['base-types'],\n        'domain-dictionary.ts': ['base-types']\n      };\n      \n      // Simple check for circular dependencies\n      const checkCircular = (module: string, visited: Set<string> = new Set()): boolean => {\n        if (visited.has(module)) return true;\n        visited.add(module);\n        \n        const deps = imports[module as keyof typeof imports] || [];\n        for (const dep of deps) {\n          if (checkCircular(dep + '.ts', new Set(visited))) {\n            return true;\n          }\n        }\n        \n        return false;\n      };\n      \n      for (const module of Object.keys(imports)) {\n        expect(checkCircular(module)).toBe(false);\n      }\n    });\n  });\n});"],"version":3}