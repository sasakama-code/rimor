{"file":"/Users/sasakama/Projects/Rimor/src/security/analysis/search-based-inference.ts","mappings":"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","names":[],"sources":["/Users/sasakama/Projects/Rimor/src/security/analysis/search-based-inference.ts"],"sourcesContent":["/**\n * 探索ベース型推論エンジン\n * arXiv:2504.18529v2 \"Practical Type-Based Taint Checking and Inference\" Section 6の実装\n * \n * このエンジンは、プログラムコードから自動的に型クオリファイアを推論します。\n */\n\nimport * as ts from 'typescript';\nimport {\n  TaintQualifier,\n  TypeConstraint,\n  TypeInferenceHint,\n  TypeConstructors,\n  SubtypingChecker,\n  TypeGuards,\n  QualifiedType\n} from '../types/checker-framework-types';\nimport { TaintLevel, TaintSource } from '../types/taint';\n\n/**\n * 推論の状態\n */\ninterface InferenceState {\n  /** 変数名から型クオリファイアへのマッピング */\n  typeMap: Map<string, TaintQualifier>;\n  /** 生成された制約のリスト */\n  constraints: TypeConstraint[];\n  /** 推論の信頼度 */\n  confidence: Map<string, number>;\n  /** 探索の履歴 */\n  searchHistory: SearchStep[];\n}\n\n/**\n * 探索のステップ\n */\ninterface SearchStep {\n  variable: string;\n  previousType: TaintQualifier | null;\n  newType: TaintQualifier;\n  reason: string;\n  timestamp: number;\n}\n\n/**\n * 制約ソルバーの結果\n */\ninterface SolverResult {\n  success: boolean;\n  solution: Map<string, TaintQualifier>;\n  unsatisfiableConstraints: TypeConstraint[];\n  iterations: number;\n}\n\n/**\n * 探索ベース推論エンジン\n * 論文のAlgorithm 1を実装\n */\nexport class SearchBasedInferenceEngine {\n  private typeChecker: ts.TypeChecker | null = null;\n  private sourceFile: ts.SourceFile | null = null;\n  private maxIterations = 1000;\n  private convergenceThreshold = 0.95;\n  \n  /**\n   * TypeScriptのソースコードから型クオリファイアを推論\n   */\n  async inferTypes(sourceCode: string, fileName: string = 'temp.ts'): Promise<InferenceState> {\n    // TypeScript ASTを生成\n    this.sourceFile = ts.createSourceFile(\n      fileName,\n      sourceCode,\n      ts.ScriptTarget.Latest,\n      true\n    );\n    \n    // 構文エラーをチェック\n    const diagnostics = (this.sourceFile as any).parseDiagnostics;\n    if (diagnostics && diagnostics.length > 0) {\n      const errorMessages = diagnostics.map((d: any) => \n        ts.flattenDiagnosticMessageText(d.messageText, '\\n')\n      ).join('; ');\n      throw new Error(`Syntax error in source file: ${errorMessages}`);\n    }\n    \n    // 初期状態を作成\n    const state: InferenceState = {\n      typeMap: new Map(),\n      constraints: [],\n      confidence: new Map(),\n      searchHistory: []\n    };\n    \n    // Phase 1: 制約の生成\n    this.generateConstraints(this.sourceFile, state);\n    \n    // Phase 2: 初期型の推定\n    this.assignInitialTypes(state);\n    \n    // Phase 3: 探索ベースの最適化\n    await this.optimizeTypes(state);\n    \n    // Phase 4: 制約の検証\n    this.validateConstraints(state);\n    \n    return state;\n  }\n  \n  /**\n   * Phase 1: 制約の生成\n   * 論文のSection 6.1に対応\n   */\n  private generateConstraints(node: ts.Node, state: InferenceState): void {\n    // 関数宣言から制約を生成\n    if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node)) {\n      this.generateFunctionConstraints(node, state);\n    }\n    \n    // パラメータから制約を生成\n    if (ts.isParameter(node)) {\n      this.generateParameterConstraints(node, state);\n    }\n    \n    // 変数宣言から制約を生成\n    if (ts.isVariableDeclaration(node)) {\n      this.generateVariableConstraints(node, state);\n    }\n    \n    // 代入文から制約を生成\n    if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {\n      this.generateAssignmentConstraints(node, state);\n    }\n    \n    // メソッド呼び出しから制約を生成\n    if (ts.isCallExpression(node)) {\n      this.generateMethodCallConstraints(node, state);\n    }\n    \n    // 条件文から制約を生成\n    if (ts.isIfStatement(node)) {\n      this.generateConditionalConstraints(node, state);\n    }\n    \n    // 子ノードを再帰的に処理\n    ts.forEachChild(node, child => this.generateConstraints(child, state));\n  }\n  \n  /**\n   * 関数宣言から制約を生成\n   */\n  private generateFunctionConstraints(node: ts.FunctionDeclaration | ts.MethodDeclaration, state: InferenceState): void {\n    // パラメータの処理\n    if (node.parameters) {\n      node.parameters.forEach(param => {\n        const paramName = param.name.getText();\n        // ユーザー入力を示唆する名前のパラメータは@Taintedとして推論\n        if (this.isUserInputName(paramName)) {\n          state.typeMap.set(paramName, '@Tainted');\n          state.confidence.set(paramName, 0.8);\n        } else {\n          state.typeMap.set(paramName, '@PolyTaint');\n          state.confidence.set(paramName, 0.5);\n        }\n      });\n    }\n  }\n  \n  /**\n   * パラメータから制約を生成\n   */\n  private generateParameterConstraints(node: ts.ParameterDeclaration, state: InferenceState): void {\n    const paramName = node.name.getText();\n    if (!state.typeMap.has(paramName)) {\n      // ユーザー入力を示唆する名前のパラメータ\n      if (this.isUserInputName(paramName)) {\n        state.typeMap.set(paramName, '@Tainted');\n        state.confidence.set(paramName, 0.8);\n      } else {\n        state.typeMap.set(paramName, '@PolyTaint');\n        state.confidence.set(paramName, 0.5);\n      }\n    }\n  }\n  \n  /**\n   * 変数宣言から制約を生成\n   */\n  private generateVariableConstraints(node: ts.VariableDeclaration, state: InferenceState): void {\n    const varName = node.name.getText();\n    const initializer = node.initializer;\n    \n    // 変数を型マップに追加（初期値なしでも）\n    if (!state.typeMap.has(varName)) {\n      state.typeMap.set(varName, '@PolyTaint');\n      state.confidence.set(varName, 0.5);\n    }\n    \n    if (!initializer) return;\n    \n    // ユーザー入力の検出\n    if (this.isUserInput(initializer)) {\n      state.constraints.push({\n        type: 'equality',\n        lhs: varName,\n        rhs: '@Tainted',\n        location: this.getLocation(node)\n      });\n      state.typeMap.set(varName, '@Tainted');\n      state.confidence.set(varName, 0.9);\n    }\n    \n    // リテラルの検出\n    else if (ts.isStringLiteral(initializer) || ts.isNumericLiteral(initializer)) {\n      state.constraints.push({\n        type: 'equality',\n        lhs: varName,\n        rhs: '@Untainted',\n        location: this.getLocation(node)\n      });\n      state.typeMap.set(varName, '@Untainted');\n      state.confidence.set(varName, 1.0);\n    }\n    \n    // 他の変数からの代入\n    else if (ts.isIdentifier(initializer)) {\n      const rhsName = initializer.getText();\n      state.constraints.push({\n        type: 'subtype',\n        lhs: rhsName,\n        rhs: varName,\n        location: this.getLocation(node)\n      });\n      \n      // 右辺の型を直接コピー（型の伝播）\n      const rhsType = state.typeMap.get(rhsName);\n      if (rhsType && rhsType !== '@PolyTaint') {\n        state.typeMap.set(varName, rhsType);\n        state.confidence.set(varName, state.confidence.get(rhsName) || 0.8);\n      } else {\n        state.confidence.set(varName, 0.8);\n      }\n    }\n    \n    // メソッド呼び出しの検出\n    else if (ts.isCallExpression(initializer)) {\n      const methodName = initializer.expression.getText();\n      \n      // サニタイザーの検出\n      if (this.isSanitizer(initializer)) {\n        state.constraints.push({\n          type: 'equality',\n          lhs: varName,\n          rhs: '@Untainted',\n          location: this.getLocation(node)\n        });\n        state.confidence.set(varName, 0.95);\n      }\n      // ユーザー入力取得関数の検出\n      else if (this.isUserInput(initializer)) {\n        state.constraints.push({\n          type: 'equality',\n          lhs: varName,\n          rhs: '@Tainted',\n          location: this.getLocation(node)\n        });\n        state.confidence.set(varName, 0.9);\n      }\n      // その他のメソッド呼び出し\n      else {\n        // 引数が汚染されていれば結果も汚染される可能性\n        state.confidence.set(varName, 0.6);\n      }\n    }\n  }\n  \n  /**\n   * 代入文から制約を生成\n   */\n  private generateAssignmentConstraints(node: ts.BinaryExpression, state: InferenceState): void {\n    const lhs = node.left.getText();\n    const rhs = node.right;\n    \n    if (ts.isIdentifier(rhs)) {\n      // 変数から変数への代入\n      state.constraints.push({\n        type: 'subtype',\n        lhs: rhs.getText(),\n        rhs: lhs,\n        location: this.getLocation(node)\n      });\n    }\n    else if (this.isSanitizer(rhs)) {\n      // サニタイザーの適用\n      state.constraints.push({\n        type: 'equality',\n        lhs: lhs,\n        rhs: '@Untainted',\n        location: this.getLocation(node)\n      });\n      state.confidence.set(lhs, 0.95);\n    }\n  }\n  \n  /**\n   * メソッド呼び出しから制約を生成\n   */\n  private generateMethodCallConstraints(node: ts.CallExpression, state: InferenceState): void {\n    const methodName = node.expression.getText();\n    \n    // セキュリティ関連メソッドのパターンマッチング\n    if (this.isSecuritySink(methodName)) {\n      // 引数は@Untaintedである必要がある\n      node.arguments.forEach((arg, index) => {\n        if (ts.isIdentifier(arg)) {\n          state.constraints.push({\n            type: 'subtype',\n            lhs: arg.getText(),\n            rhs: '@Untainted',\n            location: this.getLocation(arg)\n          });\n        }\n      });\n    }\n  }\n  \n  /**\n   * 条件文から制約を生成（フロー感度）\n   */\n  private generateConditionalConstraints(node: ts.IfStatement, state: InferenceState): void {\n    const condition = node.expression;\n    \n    // 検証条件の検出\n    if (this.isValidationCheck(condition)) {\n      // then節では変数が@Untaintedになる可能性\n      const validatedVar = this.extractValidatedVariable(condition);\n      if (validatedVar) {\n        state.constraints.push({\n          type: 'flow',\n          lhs: validatedVar,\n          rhs: '@Untainted',\n          location: this.getLocation(node.thenStatement)\n        });\n      }\n    }\n  }\n  \n  /**\n   * Phase 2: 初期型の推定\n   * 論文のSection 6.2に対応\n   */\n  private assignInitialTypes(state: InferenceState): void {\n    // すべての変数を収集\n    const variables = new Set<string>();\n    state.constraints.forEach(c => {\n      if (typeof c.lhs === 'string') variables.add(c.lhs);\n      if (typeof c.rhs === 'string' && !c.rhs.startsWith('@')) variables.add(c.rhs);\n    });\n    \n    // デフォルトは@Tainted（保守的）\n    variables.forEach(variable => {\n      if (!state.typeMap.has(variable)) {\n        state.typeMap.set(variable, '@Tainted');\n        // 信頼度が設定されていない場合のみデフォルト値を設定\n        if (!state.confidence.has(variable)) {\n          state.confidence.set(variable, 0.5);\n        }\n      }\n    });\n    \n    // 明示的な制約から初期型を設定\n    state.constraints.forEach(constraint => {\n      if (constraint.type === 'equality' && typeof constraint.lhs === 'string') {\n        state.typeMap.set(constraint.lhs, constraint.rhs as TaintQualifier);\n      }\n    });\n  }\n  \n  /**\n   * Phase 3: 探索ベースの最適化\n   * 論文のAlgorithm 1の実装\n   */\n  private async optimizeTypes(state: InferenceState): Promise<void> {\n    let iteration = 0;\n    let converged = false;\n    \n    while (!converged && iteration < this.maxIterations) {\n      iteration++;\n      \n      // 現在の解の評価\n      const currentScore = this.evaluateSolution(state);\n      \n      // 候補となる型の変更を生成\n      const candidates = this.generateCandidates(state);\n      \n      // 最良の変更を選択\n      let bestCandidate = null;\n      let bestScore = currentScore;\n      \n      for (const candidate of candidates) {\n        // 変更を適用\n        this.applyCandidate(candidate, state);\n        \n        // 新しい解を評価\n        const newScore = this.evaluateSolution(state);\n        \n        if (newScore > bestScore) {\n          bestScore = newScore;\n          bestCandidate = candidate;\n        }\n        \n        // 変更を元に戻す\n        this.revertCandidate(candidate, state);\n      }\n      \n      // 最良の変更を適用\n      if (bestCandidate) {\n        this.applyCandidate(bestCandidate, state);\n        this.recordSearchStep(bestCandidate, state);\n      } else {\n        // 改善が見つからない場合は収束\n        converged = true;\n        \n        // 探索が実行されたことを記録（候補が評価された場合）\n        if (candidates.length > 0 && state.searchHistory.length === 0) {\n          state.searchHistory.push({\n            variable: 'optimization_complete',\n            previousType: null,\n            newType: '@Tainted' as TaintQualifier,\n            reason: 'no_improvement_found',\n            timestamp: Date.now()\n          });\n        }\n      }\n      \n      // 収束判定\n      if (bestScore > this.convergenceThreshold) {\n        converged = true;\n      }\n    }\n  }\n  \n  /**\n   * 候補となる型の変更を生成\n   */\n  private generateCandidates(state: InferenceState): TypeChangeCandidate[] {\n    const candidates: TypeChangeCandidate[] = [];\n    \n    // 各変数について可能な型変更を生成\n    state.typeMap.forEach((currentType, variable) => {\n      // @PolyTaint -> 具体的な型への解決\n      if (currentType === '@PolyTaint') {\n        // 制約から推論される型を試す\n        let hasUserInputConstraint = false;\n        let hasUntaintedConstraint = false;\n        \n        state.constraints.forEach(constraint => {\n          if (constraint.type === 'subtype' && constraint.rhs === variable) {\n            const lhsType = typeof constraint.lhs === 'string' \n              ? state.typeMap.get(constraint.lhs) \n              : constraint.lhs;\n            \n            if (lhsType === '@Tainted') hasUserInputConstraint = true;\n            if (lhsType === '@Untainted') hasUntaintedConstraint = true;\n          }\n        });\n        \n        if (hasUserInputConstraint) {\n          candidates.push({\n            variable,\n            oldType: '@PolyTaint',\n            newType: '@Tainted',\n            reason: 'inferred_from_constraint'\n          });\n        } else if (hasUntaintedConstraint) {\n          candidates.push({\n            variable,\n            oldType: '@PolyTaint',\n            newType: '@Untainted',\n            reason: 'inferred_from_constraint'\n          });\n        } else {\n          // デフォルトは両方の可能性を試す\n          candidates.push({\n            variable,\n            oldType: '@PolyTaint',\n            newType: '@Tainted',\n            reason: 'default_tainted'\n          });\n          candidates.push({\n            variable,\n            oldType: '@PolyTaint',\n            newType: '@Untainted',\n            reason: 'default_untainted'\n          });\n        }\n      }\n      \n      // @Tainted -> @Untainted への昇格を試みる\n      else if (currentType === '@Tainted') {\n        candidates.push({\n          variable,\n          oldType: '@Tainted',\n          newType: '@Untainted',\n          reason: 'promotion'\n        });\n      }\n      \n      // @Untainted -> @Tainted への降格（制約違反の解消のため）\n      else if (currentType === '@Untainted') {\n        candidates.push({\n          variable,\n          oldType: '@Untainted',\n          newType: '@Tainted',\n          reason: 'demotion'\n        });\n      }\n    });\n    \n    return candidates;\n  }\n  \n  /**\n   * 解の評価関数\n   * 論文のSection 6.3で説明されているヒューリスティクス\n   */\n  private evaluateSolution(state: InferenceState): number {\n    let score = 0;\n    let totalConstraints = state.constraints.length;\n    let satisfiedConstraints = 0;\n    \n    // 制約の満足度を評価\n    state.constraints.forEach(constraint => {\n      if (this.isConstraintSatisfied(constraint, state)) {\n        satisfiedConstraints++;\n        score += 1.0;\n      } else {\n        // 制約違反のペナルティ\n        score -= 0.5;\n      }\n    });\n    \n    // @Untaintedの数を最大化（セキュリティを保ちつつ）\n    let untaintedCount = 0;\n    state.typeMap.forEach(type => {\n      if (type === '@Untainted') {\n        untaintedCount++;\n        score += 0.1;\n      }\n    });\n    \n    // 信頼度による重み付け\n    let confidenceBonus = 0;\n    state.typeMap.forEach((type, variable) => {\n      const confidence = state.confidence.get(variable) || 0.5;\n      confidenceBonus += confidence * 0.05;\n    });\n    score += confidenceBonus;\n    \n    // 正規化\n    return score / (totalConstraints + state.typeMap.size);\n  }\n  \n  /**\n   * 制約が満たされているかチェック\n   */\n  private isConstraintSatisfied(constraint: TypeConstraint, state: InferenceState): boolean {\n    const lhsType = typeof constraint.lhs === 'string' \n      ? state.typeMap.get(constraint.lhs) || '@Tainted'\n      : constraint.lhs;\n    const rhsType = typeof constraint.rhs === 'string' && !constraint.rhs.startsWith('@')\n      ? state.typeMap.get(constraint.rhs) || '@Tainted'\n      : constraint.rhs as TaintQualifier;\n    \n    switch (constraint.type) {\n      case 'subtype':\n        return SubtypingChecker.isSubtype(lhsType, rhsType);\n        \n      case 'equality':\n        return lhsType === rhsType;\n        \n      case 'flow':\n        // フロー制約は特殊処理\n        return true; // 簡略化のため常に満たされるとする\n        \n      default:\n        return false;\n    }\n  }\n  \n  /**\n   * Phase 4: 制約の検証\n   */\n  private validateConstraints(state: InferenceState): void {\n    const violations: TypeConstraint[] = [];\n    \n    state.constraints.forEach(constraint => {\n      if (!this.isConstraintSatisfied(constraint, state)) {\n        violations.push(constraint);\n      }\n    });\n    \n    if (violations.length > 0) {\n      console.warn(`Found ${violations.length} unsatisfied constraints`);\n      // 必要に応じてエラー処理\n    }\n  }\n  \n  /**\n   * ヘルパーメソッド群\n   */\n  \n  private isUserInput(node: ts.Node): boolean {\n    const text = node.getText();\n    const patterns = ['req.body', 'req.query', 'req.params', 'getUserInput', 'prompt'];\n    return patterns.some(pattern => text.includes(pattern));\n  }\n  \n  private isSanitizer(node: ts.Node): boolean {\n    const text = node.getText();\n    const patterns = ['sanitize', 'escape', 'validate', 'clean', 'purify'];\n    return patterns.some(pattern => text.includes(pattern));\n  }\n  \n  private isSecuritySink(methodName: string): boolean {\n    const sinks = ['executeQuery', 'innerHTML', 'eval', 'exec', 'query'];\n    return sinks.some(sink => methodName.includes(sink));\n  }\n  \n  private isValidationCheck(condition: ts.Expression): boolean {\n    const text = condition.getText();\n    return text.includes('isValid') || text.includes('validate') || text.includes('check');\n  }\n  \n  private extractValidatedVariable(condition: ts.Expression): string | null {\n    // 簡略化: 最初の識別子を返す\n    let variable: string | null = null;\n    \n    const visit = (node: ts.Node) => {\n      if (ts.isIdentifier(node) && !variable) {\n        variable = node.getText();\n      }\n      ts.forEachChild(node, visit);\n    };\n    \n    visit(condition);\n    return variable;\n  }\n  \n  private getLocation(node: ts.Node): { file: string; line: number; column: number } {\n    const sourceFile = this.sourceFile!;\n    const { line, character } = sourceFile.getLineAndCharacterOfPosition(node.getStart());\n    \n    return {\n      file: sourceFile.fileName,\n      line: line + 1,\n      column: character + 1\n    };\n  }\n  \n  private applyCandidate(candidate: TypeChangeCandidate, state: InferenceState): void {\n    state.typeMap.set(candidate.variable, candidate.newType);\n  }\n  \n  private revertCandidate(candidate: TypeChangeCandidate, state: InferenceState): void {\n    state.typeMap.set(candidate.variable, candidate.oldType);\n  }\n  \n  private recordSearchStep(candidate: TypeChangeCandidate, state: InferenceState): void {\n    state.searchHistory.push({\n      variable: candidate.variable,\n      previousType: candidate.oldType,\n      newType: candidate.newType,\n      reason: candidate.reason,\n      timestamp: Date.now()\n    });\n  }\n  \n  /**\n   * ユーザー入力を示唆する名前かどうかを判定\n   */\n  private isUserInputName(name: string): boolean {\n    const userInputPatterns = [\n      /^user/i,\n      /input/i,\n      /request/i,\n      /query/i,\n      /param/i,\n      /arg/i,\n      /data$/i,\n      /value$/i\n    ];\n    \n    return userInputPatterns.some(pattern => pattern.test(name));\n  }\n}\n\n/**\n * 型変更の候補\n */\ninterface TypeChangeCandidate {\n  variable: string;\n  oldType: TaintQualifier;\n  newType: TaintQualifier;\n  reason: string;\n}\n\n/**\n * 制約ソルバー\n * 論文のSection 6.4で説明されている制約解決アルゴリズム\n */\nexport class ConstraintSolver {\n  /**\n   * 制約システムを解く\n   */\n  solve(constraints: TypeConstraint[], initialTypes: Map<string, TaintQualifier>): SolverResult {\n    const solution = new Map(initialTypes);\n    const unsatisfiable: TypeConstraint[] = [];\n    let iterations = 0;\n    let changed = true;\n    \n    // 固定点に達するまで繰り返す\n    while (changed && iterations < 100) {\n      changed = false;\n      iterations++;\n      \n      for (const constraint of constraints) {\n        if (!this.processConstraint(constraint, solution)) {\n          unsatisfiable.push(constraint);\n        } else {\n          changed = true;\n        }\n      }\n    }\n    \n    return {\n      success: unsatisfiable.length === 0,\n      solution,\n      unsatisfiableConstraints: unsatisfiable,\n      iterations\n    };\n  }\n  \n  private processConstraint(\n    constraint: TypeConstraint, \n    solution: Map<string, TaintQualifier>\n  ): boolean {\n    const lhsType = typeof constraint.lhs === 'string'\n      ? solution.get(constraint.lhs) || '@Tainted'\n      : constraint.lhs;\n    const rhsType = typeof constraint.rhs === 'string' && !constraint.rhs.startsWith('@')\n      ? solution.get(constraint.rhs) || '@Tainted'\n      : constraint.rhs as TaintQualifier;\n    \n    switch (constraint.type) {\n      case 'subtype':\n        // lhs <: rhs を満たすように調整\n        if (!SubtypingChecker.isSubtype(lhsType, rhsType)) {\n          if (typeof constraint.rhs === 'string' && !constraint.rhs.startsWith('@')) {\n            // rhsを@Taintedに変更\n            solution.set(constraint.rhs, '@Tainted');\n            return true;\n          }\n          return false;\n        }\n        // 制約が満たされている場合、より具体的な型を伝播させることも可能\n        // x <: y かつ x = @Untainted の場合、y も @Untainted にできる\n        if (lhsType === '@Untainted' && rhsType === '@Tainted' && \n            typeof constraint.rhs === 'string' && !constraint.rhs.startsWith('@')) {\n          solution.set(constraint.rhs, '@Untainted');\n          return true;\n        }\n        return true;\n        \n      case 'equality':\n        // lhs = rhs を強制\n        if (typeof constraint.lhs === 'string') {\n          solution.set(constraint.lhs, rhsType);\n          return true;\n        }\n        return lhsType === rhsType;\n        \n      default:\n        return true;\n    }\n  }\n}\n\n/**\n * 推論結果のフォーマッター\n */\nexport class InferenceResultFormatter {\n  /**\n   * 推論結果を人間が読みやすい形式に変換\n   */\n  static format(state: InferenceState): string {\n    const lines: string[] = [];\n    \n    lines.push('=== Type Inference Results ===');\n    lines.push('');\n    \n    // 変数の型\n    lines.push('Variable Types:');\n    state.typeMap.forEach((type, variable) => {\n      const confidence = state.confidence.get(variable) || 0;\n      lines.push(`  ${variable}: ${type} (confidence: ${(confidence * 100).toFixed(0)}%)`);\n    });\n    \n    lines.push('');\n    lines.push(`Total Constraints: ${state.constraints.length}`);\n    \n    // 制約の満足度\n    let satisfied = 0;\n    state.constraints.forEach(c => {\n      if (new SearchBasedInferenceEngine()['isConstraintSatisfied'](c, state)) {\n        satisfied++;\n      }\n    });\n    lines.push(`Satisfied Constraints: ${satisfied}/${state.constraints.length}`);\n    \n    // 探索履歴\n    if (state.searchHistory.length > 0) {\n      lines.push('');\n      lines.push('Search History:');\n      state.searchHistory.slice(-5).forEach(step => {\n        lines.push(`  ${step.variable}: ${step.previousType} -> ${step.newType} (${step.reason})`);\n      });\n    }\n    \n    return lines.join('\\n');\n  }\n}"],"version":3}