{"file":"/Users/sasakama/Projects/Rimor/src/security/compatibility/taint-level-adapter.ts","mappings":"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","names":[],"sources":["/Users/sasakama/Projects/Rimor/src/security/compatibility/taint-level-adapter.ts"],"sourcesContent":["/**\n * TaintLevel列挙型から新型システムへの互換アダプター\n * arXiv:2504.18529v2への段階的移行をサポート\n * \n * このアダプターは、既存のTaintLevelベースのコードを\n * 新しい@Tainted/@Untaintedアノテーションシステムに\n * 段階的に移行するためのブリッジとして機能します。\n */\n\nimport { TaintLevel, TaintSource, TaintMetadata } from '../types/taint';\nimport { \n  TaintQualifier, \n  TypeConstructors, \n  QualifiedType,\n  TaintedType,\n  UntaintedType\n} from '../types/checker-framework-types';\n\n/**\n * TaintLevel互換アダプター\n * Dorothy Denningの格子理論から新しい型システムへの変換を提供\n */\nexport class TaintLevelAdapter {\n  /**\n   * TaintLevelから型クオリファイアへの変換\n   * 格子理論の多段階レベルを二値システムにマッピング\n   */\n  static toTaintQualifier(level: TaintLevel): TaintQualifier {\n    // CLEAN/UNTAINTEDは@Untaintedにマップ\n    if (level === 'untainted' || level === 'sanitized') {\n      return '@Untainted';\n    }\n    // その他すべては@Taintedにマップ\n    return '@Tainted';\n  }\n\n  /**\n   * TaintLevelから具体的な型への変換\n   * 信頼度情報を保持しながら新型システムに変換\n   */\n  static toQualifiedType<T>(\n    value: T, \n    level: TaintLevel,\n    source?: TaintSource,\n    metadata?: TaintMetadata\n  ): QualifiedType<T> {\n    // 信頼度の計算（0.0-1.0の範囲）\n    const confidence = this.calculateConfidence(level);\n    \n    if (level === 'untainted' || level === 'sanitized') {\n      return TypeConstructors.untainted(value, 'legacy-clean');\n    } else {\n      const sourceStr = source || (metadata?.sources && metadata.sources[0]) || 'legacy-taint';\n      return TypeConstructors.tainted(value, sourceStr, confidence);\n    }\n  }\n\n  /**\n   * 新型システムからTaintLevelへの逆変換\n   * 内部実装での格子理論使用のため\n   */\n  static fromQualifiedType<T>(qualified: QualifiedType<T>): TaintLevel {\n    if (qualified.__brand === '@Untainted') {\n      return 'untainted';\n    } else if (qualified.__brand === '@Tainted') {\n      const tainted = qualified as TaintedType<T>;\n      return this.confidenceToTaintLevel(tainted.__confidence);\n    } else {\n      // @PolyTaintは文脈依存なので、保守的にPOSSIBLY_TAINTEDとする\n      return 'possibly_tainted';\n    }\n  }\n\n  /**\n   * TaintLevelから信頼度への変換\n   */\n  private static calculateConfidence(level: TaintLevel): number {\n    switch (level) {\n      case 'untainted':\n      case 'sanitized':\n        return 0.0;\n      case 'possibly_tainted':\n        return 0.25;\n      case 'unknown':\n        return 0.5;\n      case 'tainted':\n        return 0.75;\n      case 'highly_tainted':\n        return 1.0;\n      default:\n        return 0.5; // デフォルトは中間値\n    }\n  }\n\n  /**\n   * 信頼度からTaintLevelへの逆変換\n   */\n  private static confidenceToTaintLevel(confidence: number): TaintLevel {\n    if (confidence <= 0.0) {\n      return 'untainted';\n    } else if (confidence <= 0.25) {\n      return 'possibly_tainted';\n    } else if (confidence <= 0.5) {\n      return 'unknown';\n    } else if (confidence <= 0.75) {\n      return 'tainted';\n    } else {\n      return 'highly_tainted';\n    }\n  }\n\n  /**\n   * 格子演算の互換実装\n   * 新型システムで格子理論の演算を再現\n   */\n  static join<T>(\n    a: QualifiedType<T>, \n    b: QualifiedType<T>\n  ): QualifiedType<T> {\n    // 両方が@Untaintedの場合のみ@Untainted\n    if (a.__brand === '@Untainted' && b.__brand === '@Untainted') {\n      return a;\n    }\n    \n    // いずれかが@Taintedなら結果も@Tainted\n    if (a.__brand === '@Tainted') {\n      return a;\n    } else if (b.__brand === '@Tainted') {\n      return b;\n    }\n    \n    // PolyTaintが含まれる場合は保守的に@Tainted\n    return TypeConstructors.tainted(\n      a.__value, \n      'join-operation',\n      0.5\n    );\n  }\n\n  /**\n   * 格子演算のmeet操作\n   */\n  static meet<T>(\n    a: QualifiedType<T>, \n    b: QualifiedType<T>\n  ): QualifiedType<T> {\n    // いずれかが@Untaintedなら結果も@Untainted\n    if (a.__brand === '@Untainted') {\n      return a;\n    } else if (b.__brand === '@Untainted') {\n      return b;\n    }\n    \n    // 両方が@Taintedの場合、より低い信頼度を選択\n    if (a.__brand === '@Tainted' && b.__brand === '@Tainted') {\n      const aConf = (a as TaintedType<T>).__confidence;\n      const bConf = (b as TaintedType<T>).__confidence;\n      if (aConf <= bConf) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n    \n    return a;\n  }\n\n  /**\n   * レガシーコードのための便利メソッド\n   * TaintLevelベースの比較を新型システムで実行\n   */\n  static isMoreTaintedThan<T>(\n    a: QualifiedType<T>,\n    b: QualifiedType<T>\n  ): boolean {\n    const aLevel = this.fromQualifiedType(a);\n    const bLevel = this.fromQualifiedType(b);\n    return aLevel > bLevel;\n  }\n\n  /**\n   * バッチ変換用のヘルパー\n   * 複数の値を一括で変換\n   */\n  static batchConvert<T>(\n    values: Array<{ value: T; level: TaintLevel; source?: TaintSource }>\n  ): QualifiedType<T>[] {\n    return values.map(({ value, level, source }) => \n      this.toQualifiedType(value, level, source)\n    );\n  }\n\n  /**\n   * デバッグ用の文字列表現\n   */\n  static toString<T>(qualified: QualifiedType<T>): string {\n    if (qualified.__brand === '@Untainted') {\n      return 'Untainted (safe)';\n    } else if (qualified.__brand === '@Tainted') {\n      const tainted = qualified as TaintedType<T>;\n      return `Tainted (source: ${tainted.__source}, confidence: ${tainted.__confidence})`;\n    } else {\n      return 'PolyTaint (context-dependent)';\n    }\n  }\n}\n\n/**\n * 移行期間中の便利な型エイリアス\n */\nexport type LegacyCompatibleType<T> = QualifiedType<T> & {\n  __legacyLevel?: TaintLevel;\n};\n\n/**\n * 移行支援ユーティリティ\n */\nexport class MigrationHelper {\n  /**\n   * レガシーAPIの互換実装\n   * 既存コードの最小限の変更で新システムを使用可能に\n   */\n  static createLegacyCompatibleAPI() {\n    return {\n      // TaintLevel定数の互換実装\n      TaintLevel: {\n        UNTAINTED: '@Untainted' as const,\n        POSSIBLY_TAINTED: '@Tainted' as const,\n        LIKELY_TAINTED: '@Tainted' as const,\n        DEFINITELY_TAINTED: '@Tainted' as const,\n        HIGHLY_TAINTED: '@Tainted' as const\n      },\n      \n      // 格子演算の互換実装\n      TaintLattice: {\n        join: TaintLevelAdapter.join,\n        meet: TaintLevelAdapter.meet,\n        lessThanOrEqual: <T>(a: QualifiedType<T>, b: QualifiedType<T>) => \n          !TaintLevelAdapter.isMoreTaintedThan(a, b)\n      }\n    };\n  }\n\n  /**\n   * 段階的移行のためのデコレータ\n   * 既存メソッドを新型システムで自動的にラップ\n   */\n  static wrapLegacyMethod<T extends (...args: any[]) => TaintLevel>(\n    method: T\n  ): (...args: Parameters<T>) => TaintQualifier {\n    return (...args: Parameters<T>) => {\n      const legacyResult = method(...args);\n      return TaintLevelAdapter.toTaintQualifier(legacyResult);\n    };\n  }\n}\n\n/**\n * 移行状況の追跡\n */\nexport class MigrationTracker {\n  private static migrationStats = new Map<string, {\n    total: number;\n    migrated: number;\n    lastUpdated: Date;\n  }>();\n\n  static recordMigration(fileName: string, total: number, migrated: number): void {\n    this.migrationStats.set(fileName, {\n      total,\n      migrated,\n      lastUpdated: new Date()\n    });\n  }\n\n  static getMigrationProgress(): {\n    overallProgress: number;\n    fileStats: Array<{ file: string; progress: number }>;\n  } {\n    let totalItems = 0;\n    let migratedItems = 0;\n    const fileStats: Array<{ file: string; progress: number }> = [];\n\n    for (const [file, stats] of this.migrationStats) {\n      totalItems += stats.total;\n      migratedItems += stats.migrated;\n      fileStats.push({\n        file,\n        progress: stats.total > 0 ? (stats.migrated / stats.total) * 100 : 0\n      });\n    }\n\n    return {\n      overallProgress: totalItems > 0 ? (migratedItems / totalItems) * 100 : 0,\n      fileStats\n    };\n  }\n}"],"version":3}