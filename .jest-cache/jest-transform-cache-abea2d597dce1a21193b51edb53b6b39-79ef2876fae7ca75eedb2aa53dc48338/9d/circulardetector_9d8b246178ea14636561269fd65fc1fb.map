{"file":"/Users/sasakama/Projects/Rimor/src/analyzers/dependency-analysis/circular-detector.ts","mappings":";AAAA;;;;;;;GAOG;;;AAIH;;GAEG;AACH,MAAa,0BAA0B;IACrC;;OAEG;IACH,0BAA0B,CAAC,YAA8B;QACvD,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;QAC5C,MAAM,MAAM,GAAuB,EAAE,CAAC;QACtC,MAAM,OAAO,GAAG,IAAI,GAAG,EAAU,CAAC;QAClC,MAAM,cAAc,GAAG,IAAI,GAAG,EAAU,CAAC;QACzC,MAAM,cAAc,GAAG,IAAI,GAAG,EAAU,CAAC;QAEzC,KAAK,MAAM,IAAI,IAAI,KAAK,CAAC,IAAI,EAAE,EAAE,CAAC;YAChC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;gBACvB,MAAM,cAAc,GAAG,IAAI,CAAC,GAAG,CAC7B,IAAI,EACJ,KAAK,EACL,OAAO,EACP,cAAc,EACd,EAAE,CACH,CAAC;gBAEF,KAAK,MAAM,KAAK,IAAI,cAAc,EAAE,CAAC;oBACnC,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;oBACzC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;wBAClC,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;wBAC7B,MAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;wBAC/C,MAAM,CAAC,IAAI,CAAC;4BACV,KAAK,EAAE,KAAK;4BACZ,QAAQ,EAAE,QAAwC;4BAClD,UAAU,EAAE,IAAI,CAAC,kBAAkB,CAAC;gCAClC,KAAK,EAAE,KAAK;gCACZ,QAAQ,EAAE,QAAwC;gCAClD,UAAU,EAAE,EAAE;6BACf,CAAC;yBACH,CAAC,CAAC;oBACL,CAAC;gBACH,CAAC;YACH,CAAC;QACH,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACK,UAAU,CAAC,YAA8B;QAC/C,MAAM,KAAK,GAAG,IAAI,GAAG,EAAoB,CAAC;QAE1C,KAAK,MAAM,GAAG,IAAI,YAAY,EAAE,CAAC;YAC/B,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;gBACzB,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;YAC1B,CAAC;YACD,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,OAAO,CAAC,CAAC;QACnC,CAAC;QAED,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;OAEG;IACK,GAAG,CACT,IAAY,EACZ,KAA4B,EAC5B,OAAoB,EACpB,cAA2B,EAC3B,IAAc;QAEd,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAClB,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACzB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEhB,MAAM,MAAM,GAAe,EAAE,CAAC;QAC9B,MAAM,SAAS,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;QAExC,KAAK,MAAM,QAAQ,IAAI,SAAS,EAAE,CAAC;YACjC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;gBAC3B,MAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAC3B,QAAQ,EACR,KAAK,EACL,OAAO,EACP,cAAc,EACd,CAAC,GAAG,IAAI,CAAC,CACV,CAAC;gBACF,MAAM,CAAC,IAAI,CAAC,GAAG,YAAY,CAAC,CAAC;YAC/B,CAAC;iBAAM,IAAI,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;gBACxC,QAAQ;gBACR,MAAM,eAAe,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;gBAC/C,IAAI,eAAe,KAAK,CAAC,CAAC,EAAE,CAAC;oBAC3B,MAAM,KAAK,GAAG,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,EAAE,QAAQ,CAAC,CAAC;oBACzD,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACrB,CAAC;YACH,CAAC;QACH,CAAC;QAED,cAAc,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAC5B,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACK,WAAW,CAAC,KAAe;QACjC,MAAM,MAAM,GAAG,CAAC,GAAG,KAAK,CAAC,CAAC,IAAI,EAAE,CAAC;QACjC,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAC;IAED;;OAEG;IACH,iBAAiB,CAAC,KAAe;QAC/B,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,mBAAmB;QAEpD,IAAI,MAAM,IAAI,CAAC,EAAE,CAAC;YAChB,OAAO,OAAO,CAAC,CAAC,gBAAgB;QAClC,CAAC;aAAM,IAAI,MAAM,IAAI,CAAC,EAAE,CAAC;YACvB,OAAO,SAAS,CAAC,CAAC,cAAc;QAClC,CAAC;aAAM,CAAC;YACN,OAAO,MAAM,CAAC,CAAC,aAAa;QAC9B,CAAC;IACH,CAAC;IAED;;OAEG;IACH,kBAAkB,CAAC,KAAuB;QACxC,MAAM,WAAW,GAAa,EAAE,CAAC;QACjC,MAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC;QAEhC,IAAI,QAAQ,KAAK,OAAO,EAAE,CAAC;YACzB,WAAW,CAAC,IAAI,CAAC,+DAA+D,CAAC,CAAC;YAClF,WAAW,CAAC,IAAI,CAAC,uEAAuE,CAAC,CAAC;QAC5F,CAAC;aAAM,IAAI,QAAQ,KAAK,SAAS,EAAE,CAAC;YAClC,WAAW,CAAC,IAAI,CAAC,mDAAmD,CAAC,CAAC;YACtE,WAAW,CAAC,IAAI,CAAC,8DAA8D,CAAC,CAAC;QACnF,CAAC;aAAM,CAAC;YACN,WAAW,CAAC,IAAI,CAAC,2CAA2C,CAAC,CAAC;YAC9D,WAAW,CAAC,IAAI,CAAC,6CAA6C,CAAC,CAAC;QAClE,CAAC;QAED,qBAAqB;QACrB,WAAW,CAAC,IAAI,CAAC,+DAA+D,CAAC,CAAC;QAElF,OAAO,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAChC,CAAC;IAED;;OAEG;IACH,aAAa,CACX,KAAuB,EACvB,eAAiC;QAMjC,MAAM,aAAa,GAAG,IAAI,GAAG,EAAU,CAAC;QACxC,MAAM,SAAS,GAAG,IAAI,GAAG,EAAU,CAAC;QAEpC,iBAAiB;QACjB,KAAK,MAAM,IAAI,IAAI,KAAK,CAAC,KAAK,EAAE,CAAC;YAC/B,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAExB,4BAA4B;YAC5B,KAAK,MAAM,GAAG,IAAI,eAAe,EAAE,CAAC;gBAClC,IAAI,GAAG,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;oBAC/B,aAAa,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;oBAE5B,IAAI,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC;wBAC/D,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;oBAC1B,CAAC;gBACH,CAAC;YACH,CAAC;QACH,CAAC;QAED,SAAS;QACT,IAAI,QAAQ,GAAiC,KAAK,CAAC,QAAQ,CAAC;QAC5D,IAAI,aAAa,CAAC,IAAI,GAAG,EAAE,EAAE,CAAC;YAC5B,QAAQ,GAAG,OAAO,CAAC;QACrB,CAAC;aAAM,IAAI,aAAa,CAAC,IAAI,GAAG,CAAC,IAAI,QAAQ,KAAK,OAAO,EAAE,CAAC;YAC1D,QAAQ,GAAG,SAAS,CAAC;QACvB,CAAC;QAED,OAAO;YACL,aAAa,EAAE,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC;YACxC,SAAS,EAAE,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC;YAChC,QAAQ;SACT,CAAC;IACJ,CAAC;CACF;AA/LD,gEA+LC","names":[],"sources":["/Users/sasakama/Projects/Rimor/src/analyzers/dependency-analysis/circular-detector.ts"],"sourcesContent":["/**\n * CircularDependencyDetector\n * Issue #65: 循環依存検出専用モジュール\n * \n * SOLID原則: 単一責任（循環依存検出のみ）\n * DRY原則: グラフ走査アルゴリズムの再利用\n * KISS原則: シンプルなDFSベースの検出\n */\n\nimport { CyclicDependency, FileDependency } from '../types';\n\n/**\n * 循環依存を検出する専用クラス\n */\nexport class CircularDependencyDetector {\n  /**\n   * 循環依存を検出\n   */\n  detectCircularDependencies(dependencies: FileDependency[]): CyclicDependency[] {\n    const graph = this.buildGraph(dependencies);\n    const cycles: CyclicDependency[] = [];\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n    const detectedCycles = new Set<string>();\n\n    for (const node of graph.keys()) {\n      if (!visited.has(node)) {\n        const cyclesFromNode = this.dfs(\n          node,\n          graph,\n          visited,\n          recursionStack,\n          []\n        );\n        \n        for (const cycle of cyclesFromNode) {\n          const cycleKey = this.getCycleKey(cycle);\n          if (!detectedCycles.has(cycleKey)) {\n            detectedCycles.add(cycleKey);\n            const severity = this.calculateSeverity(cycle);\n            cycles.push({\n              files: cycle,\n              severity: severity as 'error' | 'warning' | 'info',\n              suggestion: this.suggestRefactoring({ \n                files: cycle, \n                severity: severity as 'error' | 'warning' | 'info',\n                suggestion: ''\n              })\n            });\n          }\n        }\n      }\n    }\n\n    return cycles;\n  }\n\n  /**\n   * 依存関係グラフを構築\n   */\n  private buildGraph(dependencies: FileDependency[]): Map<string, string[]> {\n    const graph = new Map<string, string[]>();\n\n    for (const dep of dependencies) {\n      if (!graph.has(dep.file)) {\n        graph.set(dep.file, []);\n      }\n      graph.set(dep.file, dep.imports);\n    }\n\n    return graph;\n  }\n\n  /**\n   * 深さ優先探索で循環を検出\n   */\n  private dfs(\n    node: string,\n    graph: Map<string, string[]>,\n    visited: Set<string>,\n    recursionStack: Set<string>,\n    path: string[]\n  ): string[][] {\n    visited.add(node);\n    recursionStack.add(node);\n    path.push(node);\n\n    const cycles: string[][] = [];\n    const neighbors = graph.get(node) || [];\n\n    for (const neighbor of neighbors) {\n      if (!visited.has(neighbor)) {\n        const nestedCycles = this.dfs(\n          neighbor,\n          graph,\n          visited,\n          recursionStack,\n          [...path]\n        );\n        cycles.push(...nestedCycles);\n      } else if (recursionStack.has(neighbor)) {\n        // 循環を検出\n        const cycleStartIndex = path.indexOf(neighbor);\n        if (cycleStartIndex !== -1) {\n          const cycle = [...path.slice(cycleStartIndex), neighbor];\n          cycles.push(cycle);\n        }\n      }\n    }\n\n    recursionStack.delete(node);\n    return cycles;\n  }\n\n  /**\n   * 循環のキーを生成（重複検出用）\n   */\n  private getCycleKey(cycle: string[]): string {\n    const sorted = [...cycle].sort();\n    return sorted.join('->');\n  }\n\n  /**\n   * 循環の重要度を計算\n   */\n  calculateSeverity(cycle: string[]): 'error' | 'warning' | 'info' {\n    const length = cycle.length - 1; // 最後の要素は最初の要素の繰り返し\n    \n    if (length <= 2) {\n      return 'error'; // 2ファイル間の直接的な循環\n    } else if (length <= 4) {\n      return 'warning'; // 3-4ファイル間の循環\n    } else {\n      return 'info'; // 5ファイル以上の循環\n    }\n  }\n\n  /**\n   * リファクタリング提案を生成\n   */\n  suggestRefactoring(cycle: CyclicDependency): string {\n    const suggestions: string[] = [];\n    const severity = cycle.severity;\n\n    if (severity === 'error') {\n      suggestions.push('Consider extracting common functionality to a separate module');\n      suggestions.push('Use dependency injection or interfaces to break the direct dependency');\n    } else if (severity === 'warning') {\n      suggestions.push('Review the module boundaries and responsibilities');\n      suggestions.push('Consider using event-driven architecture or mediator pattern');\n    } else {\n      suggestions.push('Analyze if all dependencies are necessary');\n      suggestions.push('Consider restructuring the module hierarchy');\n    }\n\n    // インターフェースベースの解決策を提案\n    suggestions.push('Create an interface or abstract class to decouple the modules');\n\n    return suggestions.join('. ');\n  }\n\n  /**\n   * 循環依存の影響範囲を分析\n   */\n  analyzeImpact(\n    cycle: CyclicDependency,\n    allDependencies: FileDependency[]\n  ): {\n    affectedFiles: string[];\n    testFiles: string[];\n    severity: 'error' | 'warning' | 'info';\n  } {\n    const affectedFiles = new Set<string>();\n    const testFiles = new Set<string>();\n\n    // 循環に含まれるファイルを追加\n    for (const file of cycle.files) {\n      affectedFiles.add(file);\n      \n      // このファイルをインポートしている他のファイルを検索\n      for (const dep of allDependencies) {\n        if (dep.imports.includes(file)) {\n          affectedFiles.add(dep.file);\n          \n          if (dep.file.includes('.test.') || dep.file.includes('.spec.')) {\n            testFiles.add(dep.file);\n          }\n        }\n      }\n    }\n\n    // 影響度を計算\n    let severity: 'error' | 'warning' | 'info' = cycle.severity;\n    if (affectedFiles.size > 10) {\n      severity = 'error';\n    } else if (affectedFiles.size > 5 && severity !== 'error') {\n      severity = 'warning';\n    }\n\n    return {\n      affectedFiles: Array.from(affectedFiles),\n      testFiles: Array.from(testFiles),\n      severity\n    };\n  }\n}"],"version":3}