{"file":"/Users/sasakama/Projects/Rimor/src/security/types/checker-framework-types.ts","mappings":"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","names":[],"sources":["/Users/sasakama/Projects/Rimor/src/security/types/checker-framework-types.ts"],"sourcesContent":["/**\n * Checker Framework互換の型定義\n * arXiv:2504.18529v2 \"Practical Type-Based Taint Checking and Inference\" の実装\n * \n * このファイルは論文で提案されている型システムをTypeScriptで実装します。\n */\n\nimport { TaintLevel } from './taint';\n\n/**\n * 汚染修飾子の型\n * 論文のSection 2.1で定義されている型修飾子\n */\nexport type TaintQualifier = '@Tainted' | '@Untainted' | '@PolyTaint';\n\n/**\n * 伝播規則の型\n */\nexport type PropagationRule = 'any' | 'all';\n\n/**\n * 型クオリファイア階層\n * @Tainted が @Untainted のスーパータイプ\n */\nexport interface TypeQualifierHierarchy {\n  '@Tainted': {\n    subtypes: ['@Untainted'];\n    supertypes: [];\n  };\n  '@Untainted': {\n    subtypes: [];\n    supertypes: ['@Tainted'];\n  };\n  '@PolyTaint': {\n    subtypes: ['@Tainted', '@Untainted'];\n    supertypes: ['@Tainted', '@Untainted'];\n  };\n}\n\n/**\n * 汚染された型 - @Tainted\n * 攻撃者に影響される可能性のある値を表す\n */\nexport interface TaintedType<T> {\n  readonly __brand: '@Tainted';\n  readonly __value: T;\n  readonly __source: string;\n  readonly __confidence: number;\n}\n\n/**\n * 清浄な型 - @Untainted\n * 完全に安全で信頼できる値を表す\n */\nexport interface UntaintedType<T> {\n  readonly __brand: '@Untainted';\n  readonly __value: T;\n  readonly __sanitizedBy?: string;\n  readonly __validatedAt?: number;\n}\n\n/**\n * ポリモーフィック汚染型 - @PolyTaint\n * メソッドの汚染挙動が引数に依存する場合に使用\n */\nexport interface PolyTaintType<T> {\n  readonly __brand: '@PolyTaint';\n  readonly __value: T;\n  readonly __parameterIndices: number[];\n  readonly __propagationRule: PropagationRule;\n}\n\n/**\n * 型クオリファイアのユニオン型\n * 論文のFigure 1に対応\n */\nexport type QualifiedType<T> = TaintedType<T> | UntaintedType<T> | PolyTaintType<T>;\n\n/**\n * 型クオリファイアのガード関数\n */\nexport const TypeGuards = {\n  isTainted<T>(value: unknown): value is TaintedType<T> {\n    return value !== null && typeof value === 'object' && \n           '__brand' in value && (value as Record<string, unknown>).__brand === '@Tainted';\n  },\n  \n  isUntainted<T>(value: unknown): value is UntaintedType<T> {\n    return value !== null && typeof value === 'object' && \n           '__brand' in value && (value as Record<string, unknown>).__brand === '@Untainted';\n  },\n  \n  isPolyTaint<T>(value: unknown): value is PolyTaintType<T> {\n    return value !== null && typeof value === 'object' && \n           '__brand' in value && (value as Record<string, unknown>).__brand === '@PolyTaint';\n  }\n};\n\n/**\n * 型コンストラクタ\n * 論文のSection 3で説明されている型構築\n */\nexport const TypeConstructors = {\n  /**\n   * 汚染された値を作成\n   */\n  tainted<T>(value: T, source: string, confidence: number = 1.0): TaintedType<T> {\n    return {\n      __brand: '@Tainted',\n      __value: value,\n      __source: source,\n      __confidence: confidence\n    };\n  },\n  \n  /**\n   * 清浄な値を作成\n   */\n  untainted<T>(value: T, sanitizedBy?: string): UntaintedType<T> {\n    return {\n      __brand: '@Untainted',\n      __value: value,\n      __sanitizedBy: sanitizedBy,\n      __validatedAt: Date.now()\n    };\n  },\n  \n  /**\n   * ポリモーフィック汚染値を作成\n   */\n  polyTaint<T>(\n    value: T, \n    parameterIndices: number[] = [], \n    propagationRule: PropagationRule = 'any'\n  ): PolyTaintType<T> {\n    return {\n      __brand: '@PolyTaint',\n      __value: value,\n      __parameterIndices: parameterIndices,\n      __propagationRule: propagationRule\n    };\n  }\n};\n\n/**\n * サブタイピング関係のチェック\n * 論文のSection 2.2で定義されている規則\n */\nexport class SubtypingChecker {\n  /**\n   * aがbのサブタイプかどうかをチェック\n   * @Untainted <: @Tainted (untaintedはtaintedのサブタイプ)\n   */\n  static isSubtype(a: TaintQualifier, b: TaintQualifier): boolean {\n    if (a === b) return true;\n    if (a === '@Untainted' && b === '@Tainted') return true;\n    if (a === '@PolyTaint') return true; // PolyTaintは文脈依存\n    return false;\n  }\n  \n  /**\n   * 代入の安全性をチェック\n   * 右辺が左辺のサブタイプである必要がある\n   */\n  static isAssignmentSafe<T>(\n    lhs: QualifiedType<T>, \n    rhs: QualifiedType<T>\n  ): boolean {\n    // @Untainted を @Tainted に代入するのは安全\n    if (TypeGuards.isUntainted(rhs) && TypeGuards.isTainted(lhs)) {\n      return true;\n    }\n    \n    // @Tainted を @Untainted に代入するのは危険\n    if (TypeGuards.isTainted(rhs) && TypeGuards.isUntainted(lhs)) {\n      return false;\n    }\n    \n    // 同じ型クオリファイア同士は安全\n    if (lhs.__brand === rhs.__brand) {\n      return true;\n    }\n    \n    // PolyTaintは文脈依存\n    if (TypeGuards.isPolyTaint(lhs) || TypeGuards.isPolyTaint(rhs)) {\n      return true; // 実行時に判定\n    }\n    \n    return false;\n  }\n}\n\n/**\n * 型の昇格・降格\n * 論文のSection 3.2で説明されている操作\n */\nexport class TypePromotion {\n  /**\n   * サニタイザーによる型の昇格\n   * @Tainted -> @Untainted\n   */\n  static sanitize<T>(tainted: TaintedType<T>, sanitizerName: string): UntaintedType<T> {\n    return TypeConstructors.untainted(tainted.__value, sanitizerName);\n  }\n  \n  /**\n   * 汚染源による型の降格\n   * @Untainted -> @Tainted\n   */\n  static taint<T>(untainted: UntaintedType<T>, source: string): TaintedType<T> {\n    return TypeConstructors.tainted(untainted.__value, source, 1.0);\n  }\n  \n  /**\n   * 条件付き昇格（検証による）\n   */\n  static conditionalPromote<T>(\n    value: QualifiedType<T>, \n    condition: (v: T) => boolean,\n    sanitizerName: string\n  ): QualifiedType<T> {\n    if (TypeGuards.isTainted(value) && condition(value.__value)) {\n      return TypeConstructors.untainted(value.__value, sanitizerName);\n    }\n    return value;\n  }\n}\n\n/**\n * 型の伝播規則\n * 論文のSection 3.3で定義されている規則\n */\nexport class TypePropagation {\n  /**\n   * 二項演算の結果の型を決定\n   * より制限的な型（@Tainted）が優先される\n   */\n  static binaryOperation<T, U, R>(\n    lhs: QualifiedType<T>,\n    rhs: QualifiedType<U>,\n    operation: (a: T, b: U) => R\n  ): QualifiedType<R> {\n    const result = operation(lhs.__value, rhs.__value);\n    \n    // どちらかが@Taintedなら結果も@Tainted\n    if (TypeGuards.isTainted(lhs) || TypeGuards.isTainted(rhs)) {\n      const source = TypeGuards.isTainted(lhs) ? lhs.__source : \n                    TypeGuards.isTainted(rhs) ? rhs.__source : 'unknown';\n      return TypeConstructors.tainted(result, source);\n    }\n    \n    // 両方が@Untaintedなら結果も@Untainted\n    if (TypeGuards.isUntainted(lhs) && TypeGuards.isUntainted(rhs)) {\n      return TypeConstructors.untainted(result);\n    }\n    \n    // PolyTaintが含まれる場合は文脈依存\n    return TypeConstructors.polyTaint(result);\n  }\n  \n  /**\n   * メソッド呼び出しの結果の型を決定\n   */\n  static methodCall<T, R>(\n    receiver: QualifiedType<T>,\n    methodName: string,\n    args: QualifiedType<unknown>[],\n    method: (...args: unknown[]) => R\n  ): QualifiedType<R> {\n    const argValues = args.map(arg => arg.__value);\n    const result = method.apply(receiver.__value, argValues);\n    \n    // レシーバーまたは引数のいずれかが汚染されていれば結果も汚染\n    const taintedInputs = [receiver, ...args].filter(TypeGuards.isTainted);\n    if (taintedInputs.length > 0) {\n      return TypeConstructors.tainted(result, taintedInputs[0].__source);\n    }\n    \n    return TypeConstructors.untainted(result);\n  }\n}\n\n/**\n * フロー感度の型チェック\n * 論文のSection 4で説明されている手法\n */\nexport class FlowSensitiveChecker {\n  private typeEnvironment: Map<string, QualifiedType<unknown>>;\n  \n  constructor() {\n    this.typeEnvironment = new Map();\n  }\n  \n  /**\n   * 変数の型を更新\n   */\n  updateType(varName: string, type: QualifiedType<unknown>): void {\n    this.typeEnvironment.set(varName, type);\n  }\n  \n  /**\n   * 変数の現在の型を取得\n   */\n  getType(varName: string): QualifiedType<unknown> | undefined {\n    return this.typeEnvironment.get(varName);\n  }\n  \n  /**\n   * 条件分岐での型の精緻化\n   */\n  refineType(\n    varName: string, \n    condition: (value: unknown) => boolean,\n    trueType: TaintQualifier,\n    falseType: TaintQualifier\n  ): void {\n    const currentType = this.typeEnvironment.get(varName);\n    if (!currentType) return;\n    \n    if (condition(currentType.__value)) {\n      // 条件が真の場合の型\n      if (trueType === '@Untainted') {\n        this.typeEnvironment.set(\n          varName, \n          TypeConstructors.untainted(currentType.__value, 'flow-refinement')\n        );\n      }\n    } else {\n      // 条件が偽の場合の型\n      if (falseType === '@Tainted' && !TypeGuards.isTainted(currentType)) {\n        this.typeEnvironment.set(\n          varName,\n          TypeConstructors.tainted(currentType.__value, 'flow-refinement')\n        );\n      }\n    }\n  }\n}\n\n/**\n * 簡便なヘルパー関数\n */\nexport function isTainted<T>(value: unknown): value is TaintedType<T> {\n  return TypeGuards.isTainted(value);\n}\n\nexport function isUntainted<T>(value: unknown): value is UntaintedType<T> {\n  return TypeGuards.isUntainted(value);\n}\n\nexport function sanitize<T>(value: TaintedType<T>, sanitizer: (val: T) => T): UntaintedType<T> {\n  return TypeConstructors.untainted(sanitizer(value.__value), 'sanitized');\n}\n\nexport function taint<T>(value: T, source: string): TaintedType<T> {\n  return TypeConstructors.tainted(value, source, 1.0);\n}\n\n/**\n * 型の互換性チェック\n * 論文のSection 5で定義されている規則\n */\nexport class TypeCompatibility {\n  /**\n   * メソッドオーバーライドの安全性をチェック\n   * 共変・反変の規則を適用\n   */\n  static isOverrideSafe(\n    baseMethod: {\n      params: TaintQualifier[];\n      return: TaintQualifier;\n    },\n    overrideMethod: {\n      params: TaintQualifier[];\n      return: TaintQualifier;\n    }\n  ): boolean {\n    // パラメータは反変（より一般的な型を受け入れる）\n    // オーバーライドメソッドは、ベースメソッドより一般的なパラメータを受け入れる必要がある\n    // つまり、base param <: override param でなければならない\n    for (let i = 0; i < baseMethod.params.length; i++) {\n      if (!SubtypingChecker.isSubtype(baseMethod.params[i], overrideMethod.params[i])) {\n        return false;\n      }\n    }\n    \n    // 戻り値は共変（より具体的な型を返す）\n    // オーバーライドメソッドは、ベースメソッドより具体的な型を返す必要がある\n    // つまり、override return <: base return でなければならない\n    return SubtypingChecker.isSubtype(overrideMethod.return, baseMethod.return);\n  }\n}\n\n/**\n * 型推論のヒント\n * 論文のSection 6で説明されている推論アルゴリズム用\n */\nexport interface TypeInferenceHint {\n  variable: string;\n  possibleTypes: TaintQualifier[];\n  confidence: number;\n  evidence: string[];\n}\n\n/**\n * 型制約\n * 推論アルゴリズムで使用される制約\n */\nexport interface TypeConstraint {\n  type: 'subtype' | 'equality' | 'flow';\n  lhs: string | TaintQualifier;\n  rhs: string | TaintQualifier;\n  location: {\n    file: string;\n    line: number;\n    column: number;\n  };\n}\n\n/**\n * ポリモーフィック型のインスタンス化\n */\nexport class PolyTaintInstantiation {\n  /**\n   * PolyTaint型を具体的な型にインスタンス化\n   */\n  static instantiate<T>(\n    polyType: PolyTaintType<T>,\n    argumentTypes: TaintQualifier[]\n  ): QualifiedType<T> {\n    const relevantArgs = polyType.__parameterIndices.map(i => argumentTypes[i]);\n    \n    if (polyType.__propagationRule === ('any' as PropagationRule)) {\n      // いずれかが@Taintedなら結果も@Tainted\n      if (relevantArgs.some(arg => arg === '@Tainted')) {\n        return TypeConstructors.tainted(polyType.__value, 'poly-instantiation');\n      }\n    } else {\n      // すべてが@Taintedなら結果も@Tainted\n      if (relevantArgs.every(arg => arg === '@Tainted')) {\n        return TypeConstructors.tainted(polyType.__value, 'poly-instantiation');\n      }\n    }\n    \n    return TypeConstructors.untainted(polyType.__value, 'poly-instantiation');\n  }\n}\n\n/**\n * 型エラー\n */\nexport class TypeQualifierError extends Error {\n  constructor(\n    message: string,\n    public readonly expected: TaintQualifier,\n    public readonly actual: TaintQualifier,\n    public readonly location?: { file: string; line: number; column: number }\n  ) {\n    super(message);\n    this.name = 'TypeQualifierError';\n  }\n}\n\n/**\n * 型チェック結果\n */\nexport interface TypeCheckResult {\n  success: boolean;\n  errors: TypeQualifierError[];\n  warnings: Array<{\n    message: string;\n    location?: { file: string; line: number; column: number };\n  }>;\n}"],"version":3}