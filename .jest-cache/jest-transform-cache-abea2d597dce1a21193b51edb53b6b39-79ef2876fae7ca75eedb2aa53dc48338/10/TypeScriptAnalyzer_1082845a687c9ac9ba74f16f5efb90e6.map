{"file":"/Users/sasakama/Projects/Rimor/src/intent-analysis/TypeScriptAnalyzer.ts","mappings":"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","names":[],"sources":["/Users/sasakama/Projects/Rimor/src/intent-analysis/TypeScriptAnalyzer.ts"],"sourcesContent":["/**\n * TypeScript Analyzer\n * v0.9.0 Phase 2 - TypeScript Compiler APIを使用した意味解析\n * TDD Green Phase - テストを通す最小限の実装\n */\n\nimport * as ts from 'typescript';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport {\n  ITypeScriptAnalyzer,\n  TypeInfo,\n  CallGraphNode,\n  MockInfo,\n  ExecutionPath\n} from './ITypeScriptAnalyzer';\n\n/**\n * TypeScript Compiler APIを使用した解析器\n * KISS原則: 最初はシンプルな実装から開始\n */\nexport class TypeScriptAnalyzer implements ITypeScriptAnalyzer {\n  private program?: ts.Program;\n  private checker?: ts.TypeChecker;\n  private initialized = false;\n  \n  /**\n   * 初期化状態を確認\n   */\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n  \n  /**\n   * TypeScriptプロジェクトを初期化\n   * YAGNI原則: 必要最小限の設定のみ\n   */\n  async initialize(configPath: string): Promise<void> {\n    const configFile = ts.readConfigFile(configPath, ts.sys.readFile);\n    if (configFile.error) {\n      throw new Error(`設定ファイルの読み込みエラー: ${configFile.error.messageText}`);\n    }\n    \n    const parsedConfig = ts.parseJsonConfigFileContent(\n      configFile.config,\n      ts.sys,\n      path.dirname(configPath)\n    );\n    \n    this.program = ts.createProgram(parsedConfig.fileNames, parsedConfig.options);\n    this.checker = this.program.getTypeChecker();\n    this.initialized = true;\n  }\n  \n  /**\n   * ファイルの型情報を取得\n   * KISS原則: 基本的な型情報の取得から開始\n   */\n  async getTypeInfo(filePath: string, position: number): Promise<TypeInfo | undefined> {\n    if (!this.program || !this.checker) {\n      throw new Error('TypeScriptAnalyzerが初期化されていません');\n    }\n    \n    const sourceFile = this.program.getSourceFile(filePath);\n    if (!sourceFile) {\n      // ファイルをプログラムに追加\n      const content = fs.readFileSync(filePath, 'utf-8');\n      const newSourceFile = ts.createSourceFile(\n        filePath,\n        content,\n        ts.ScriptTarget.Latest,\n        true\n      );\n      \n      // 簡易的な型推論（実際の実装では再度プログラムを作成する必要があるが、ここでは簡略化）\n      return this.inferTypeFromSource(newSourceFile, position);\n    }\n    \n    const node = this.findNodeAtPosition(sourceFile, position);\n    if (!node) return undefined;\n    \n    const type = this.checker.getTypeAtLocation(node);\n    return this.convertToTypeInfo(type);\n  }\n  \n  /**\n   * 関数の呼び出しグラフを構築\n   * YAGNI原則: 基本的な呼び出し関係のみ解析\n   */\n  async buildCallGraph(filePath: string): Promise<CallGraphNode[]> {\n    if (!this.program || !this.checker) {\n      throw new Error('TypeScriptAnalyzerが初期化されていません');\n    }\n    \n    const content = fs.readFileSync(filePath, 'utf-8');\n    const sourceFile = ts.createSourceFile(\n      filePath,\n      content,\n      ts.ScriptTarget.Latest,\n      true\n    );\n    \n    const callGraph: CallGraphNode[] = [];\n    const functionNodes = new Map<string, CallGraphNode>();\n    \n    // 関数定義を収集\n    this.visitNode(sourceFile, (node) => {\n      if (ts.isFunctionDeclaration(node) && node.name) {\n        const funcNode: CallGraphNode = {\n          name: node.name.text,\n          filePath,\n          line: sourceFile.getLineAndCharacterOfPosition(node.pos).line + 1,\n          calls: [],\n          calledBy: []\n        };\n        functionNodes.set(node.name.text, funcNode);\n        callGraph.push(funcNode);\n      }\n    });\n    \n    // 呼び出し関係を解析\n    this.visitNode(sourceFile, (node) => {\n      if (ts.isCallExpression(node)) {\n        const callerFunc = this.findContainingFunction(node);\n        if (callerFunc && ts.isFunctionDeclaration(callerFunc) && callerFunc.name) {\n          const callerName = callerFunc.name.text;\n          const callerNode = functionNodes.get(callerName);\n          \n          if (callerNode && ts.isIdentifier(node.expression)) {\n            const calleeName = node.expression.text;\n            const calleeNode = functionNodes.get(calleeName);\n            \n            if (calleeNode) {\n              callerNode.calls.push(calleeNode);\n              calleeNode.calledBy.push(callerNode);\n            }\n          }\n        }\n      }\n    });\n    \n    return callGraph;\n  }\n  \n  /**\n   * モックの使用状況を検出\n   * KISS原則: Jest mockの基本パターンのみ検出\n   */\n  async detectMocks(filePath: string): Promise<MockInfo[]> {\n    const content = fs.readFileSync(filePath, 'utf-8');\n    const sourceFile = ts.createSourceFile(\n      filePath,\n      content,\n      ts.ScriptTarget.Latest,\n      true\n    );\n    \n    const mocks: MockInfo[] = [];\n    \n    this.visitNode(sourceFile, (node) => {\n      // jest.mock() の検出\n      if (ts.isCallExpression(node) &&\n          ts.isPropertyAccessExpression(node.expression) &&\n          ts.isIdentifier(node.expression.expression) &&\n          node.expression.expression.text === 'jest' &&\n          node.expression.name.text === 'mock' &&\n          node.arguments.length > 0) {\n        \n        const arg = node.arguments[0];\n        if (ts.isStringLiteral(arg)) {\n          mocks.push({\n            mockedTarget: arg.text,\n            mockType: 'jest.mock',\n            hasImplementation: node.arguments.length > 1,\n            location: {\n              file: filePath,\n              line: sourceFile.getLineAndCharacterOfPosition(node.pos).line + 1\n            }\n          });\n        }\n      }\n      \n      // jest.fn() の検出\n      if (ts.isCallExpression(node) &&\n          ts.isPropertyAccessExpression(node.expression) &&\n          ts.isIdentifier(node.expression.expression) &&\n          node.expression.expression.text === 'jest' &&\n          node.expression.name.text === 'fn') {\n        \n        // mockReturnValueなどのチェーン呼び出しをチェック\n        let hasImplementation = node.arguments.length > 0;\n        \n        // jest.fn()がチェーン呼び出しの一部である場合をチェック\n        // 例: jest.fn().mockReturnValue(42).mockReturnValueOnce(1)\n        hasImplementation = hasImplementation || this.checkMockChain(node);\n        \n        mocks.push({\n          mockedTarget: 'anonymous',\n          mockType: 'jest.fn',\n          hasImplementation,\n          location: {\n            file: filePath,\n            line: sourceFile.getLineAndCharacterOfPosition(node.pos).line + 1\n          }\n        });\n      }\n    });\n    \n    return mocks;\n  }\n  \n  /**\n   * 実行パスを解析（未実装）\n   * YAGNI原則: Phase 2の後半で実装予定\n   */\n  async analyzeExecutionPaths(filePath: string): Promise<ExecutionPath[]> {\n    // TODO: Phase 2.3で実装\n    return [];\n  }\n  \n  /**\n   * 型の互換性をチェック\n   * KISS原則: 基本的な型チェックのみ\n   */\n  checkTypeCompatibility(expected: TypeInfo, actual: TypeInfo): boolean {\n    // any型は全ての型と互換\n    if (expected.typeName === 'any' || actual.typeName === 'any') {\n      return true;\n    }\n    \n    // 同じ型名なら互換\n    if (expected.typeName === actual.typeName) {\n      return true;\n    }\n    \n    // TODO: より詳細な型互換性チェック\n    return false;\n  }\n  \n  /**\n   * 未使用のエクスポートを検出（未実装）\n   * YAGNI原則: 必要になったら実装\n   */\n  async findUnusedExports(filePath: string): Promise<string[]> {\n    // TODO: 必要に応じて実装\n    return [];\n  }\n  \n  /**\n   * ヘルパーメソッド：モックチェーンをチェック\n   * DRY原則: チェーン検出ロジックの共通化\n   */\n  private checkMockChain(node: ts.CallExpression): boolean {\n    const mockMethods = [\n      'mockReturnValue', 'mockReturnValueOnce', \n      'mockImplementation', 'mockImplementationOnce',\n      'mockResolvedValue', 'mockResolvedValueOnce',\n      'mockRejectedValue', 'mockRejectedValueOnce'\n    ];\n    \n    let current: ts.Node = node;\n    \n    // チェーンを辿る\n    while (current.parent) {\n      const parent = current.parent;\n      \n      // PropertyAccessExpressionの場合\n      if (ts.isPropertyAccessExpression(parent) && parent.expression === current) {\n        const grandParent = parent.parent;\n        \n        // CallExpressionの場合\n        if (ts.isCallExpression(grandParent) && grandParent.expression === parent) {\n          const methodName = parent.name.text;\n          if (mockMethods.includes(methodName)) {\n            return true;\n          }\n          // さらにチェーンが続く可能性があるので継続\n          current = grandParent;\n          continue;\n        }\n      }\n      break;\n    }\n    \n    return false;\n  }\n  \n  /**\n   * ヘルパーメソッド：ノードを訪問\n   */\n  private visitNode(node: ts.Node, visitor: (node: ts.Node) => void): void {\n    visitor(node);\n    ts.forEachChild(node, child => this.visitNode(child, visitor));\n  }\n  \n  /**\n   * ヘルパーメソッド：位置からノードを検索\n   */\n  private findNodeAtPosition(sourceFile: ts.SourceFile, position: number): ts.Node | undefined {\n    function find(node: ts.Node): ts.Node | undefined {\n      if (position >= node.pos && position < node.end) {\n        return ts.forEachChild(node, find) || node;\n      }\n      return undefined;\n    }\n    return find(sourceFile);\n  }\n  \n  /**\n   * ヘルパーメソッド：ノードを含む関数を検索\n   */\n  private findContainingFunction(node: ts.Node): ts.FunctionDeclaration | undefined {\n    let current = node.parent;\n    while (current) {\n      if (ts.isFunctionDeclaration(current)) {\n        return current;\n      }\n      current = current.parent;\n    }\n    return undefined;\n  }\n  \n  /**\n   * ヘルパーメソッド：TypeScript型をTypeInfoに変換\n   */\n  private convertToTypeInfo(type: ts.Type): TypeInfo {\n    let typeName = this.checker!.typeToString(type);\n    \n    // 配列型の正規化（number[] -> Array）\n    if (typeName.endsWith('[]')) {\n      const elementTypeName = typeName.slice(0, -2);\n      return {\n        typeName: 'Array',\n        isPrimitive: false,\n        typeArguments: [{\n          typeName: elementTypeName,\n          isPrimitive: ['number', 'string', 'boolean'].includes(elementTypeName)\n        }]\n      };\n    }\n    \n    const isPrimitive = ['number', 'string', 'boolean', 'null', 'undefined'].includes(typeName);\n    \n    const typeInfo: TypeInfo = {\n      typeName,\n      isPrimitive\n    };\n    \n    // 配列型の処理\n    // TypeScript内部APIを使用して型引数を取得\n    const typeRef = type as ts.TypeReference;\n    if (type.symbol && type.symbol.name === 'Array' && typeRef.typeArguments) {\n      typeInfo.typeArguments = typeRef.typeArguments.map((arg: ts.Type) => \n        this.convertToTypeInfo(arg)\n      );\n    }\n    \n    // 関数型の処理\n    const signatures = type.getCallSignatures();\n    if (signatures.length > 0) {\n      const signature = signatures[0];\n      typeInfo.functionSignature = {\n        parameters: signature.parameters.map(param => {\n          const paramType = this.checker!.getTypeOfSymbolAtLocation(param, param.valueDeclaration!);\n          return this.convertToTypeInfo(paramType);\n        }),\n        returnType: this.convertToTypeInfo(signature.getReturnType())\n      };\n    }\n    \n    return typeInfo;\n  }\n  \n  /**\n   * ヘルパーメソッド：ソースから型を推論（簡易版）\n   */\n  private inferTypeFromSource(sourceFile: ts.SourceFile, position: number): TypeInfo | undefined {\n    const node = this.findNodeAtPosition(sourceFile, position);\n    if (!node) return undefined;\n    \n    // 変数宣言の型アノテーションから推論\n    if (ts.isVariableDeclaration(node.parent) && node.parent.type) {\n      const typeNode = node.parent.type;\n      return this.typeNodeToTypeInfo(typeNode);\n    }\n    \n    // 関数宣言から推論\n    if (ts.isFunctionDeclaration(node)) {\n      const params = node.parameters.map(p => \n        p.type ? this.typeNodeToTypeInfo(p.type) : { typeName: 'any', isPrimitive: false }\n      );\n      const returnType = node.type \n        ? this.typeNodeToTypeInfo(node.type)\n        : { typeName: 'void', isPrimitive: true };\n        \n      return {\n        typeName: 'function',\n        isPrimitive: false,\n        functionSignature: {\n          parameters: params,\n          returnType\n        }\n      };\n    }\n    \n    return undefined;\n  }\n  \n  /**\n   * ヘルパーメソッド：型ノードをTypeInfoに変換\n   */\n  private typeNodeToTypeInfo(typeNode: ts.TypeNode): TypeInfo {\n    if (ts.isTypeReferenceNode(typeNode) && ts.isIdentifier(typeNode.typeName)) {\n      const typeName = typeNode.typeName.text;\n      \n      // 配列型の特別処理\n      if (typeName === 'Array' && typeNode.typeArguments && typeNode.typeArguments.length > 0) {\n        return {\n          typeName: 'Array',\n          isPrimitive: false,\n          typeArguments: [this.typeNodeToTypeInfo(typeNode.typeArguments[0])]\n        };\n      }\n      \n      return {\n        typeName,\n        isPrimitive: ['number', 'string', 'boolean'].includes(typeName)\n      };\n    }\n    \n    if (ts.isArrayTypeNode(typeNode)) {\n      return {\n        typeName: 'Array',\n        isPrimitive: false,\n        typeArguments: [this.typeNodeToTypeInfo(typeNode.elementType)]\n      };\n    }\n    \n    // キーワード型\n    switch (typeNode.kind) {\n      case ts.SyntaxKind.NumberKeyword:\n        return { typeName: 'number', isPrimitive: true };\n      case ts.SyntaxKind.StringKeyword:\n        return { typeName: 'string', isPrimitive: true };\n      case ts.SyntaxKind.BooleanKeyword:\n        return { typeName: 'boolean', isPrimitive: true };\n      case ts.SyntaxKind.VoidKeyword:\n        return { typeName: 'void', isPrimitive: true };\n      case ts.SyntaxKind.AnyKeyword:\n        return { typeName: 'any', isPrimitive: false };\n      default:\n        return { typeName: 'unknown', isPrimitive: false };\n    }\n  }\n\n  /**\n   * ファイルの型情報を取得\n   * KISS原則: 基本的な型情報のマップを返す\n   */\n  async getFileTypeInfo(filePath: string): Promise<Map<string, TypeInfo>> {\n    if (!this.program || !this.checker) {\n      throw new Error('TypeScriptAnalyzerが初期化されていません');\n    }\n    \n    const typeInfoMap = new Map<string, TypeInfo>();\n    const sourceFile = this.program.getSourceFile(filePath);\n    \n    if (!sourceFile) {\n      return typeInfoMap;\n    }\n    \n    // 変数と関数の型情報を収集\n    this.visitNode(sourceFile, (node) => {\n      if (ts.isVariableDeclaration(node) && node.name && ts.isIdentifier(node.name)) {\n        const type = this.checker!.getTypeAtLocation(node);\n        const typeName = this.checker!.typeToString(type);\n        \n        typeInfoMap.set(node.name.text, {\n          typeName,\n          isPrimitive: this.isPrimitiveType(type)\n        });\n      }\n      \n      if (ts.isFunctionDeclaration(node) && node.name) {\n        const type = this.checker!.getTypeAtLocation(node);\n        const typeName = this.checker!.typeToString(type);\n        \n        typeInfoMap.set(node.name.text, {\n          typeName,\n          isPrimitive: false\n        });\n      }\n    });\n    \n    return typeInfoMap;\n  }\n\n  /**\n   * ファイルの呼び出しグラフを分析\n   * DRY原則: 既存のbuildCallGraphメソッドを再利用\n   */\n  async analyzeCallGraph(filePath: string): Promise<CallGraphNode[]> {\n    return this.buildCallGraph(filePath);\n  }\n\n  /**\n   * プリミティブ型かどうかを判定\n   * KISS原則: 基本的な型のみチェック\n   */\n  private isPrimitiveType(type: ts.Type): boolean {\n    const flags = type.flags;\n    return !!(flags & (\n      ts.TypeFlags.String |\n      ts.TypeFlags.Number |\n      ts.TypeFlags.Boolean |\n      ts.TypeFlags.Null |\n      ts.TypeFlags.Undefined |\n      ts.TypeFlags.Void\n    ));\n  }\n}"],"version":3}