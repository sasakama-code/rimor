354b2816dc22d4e9e646c04460703cd5
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const code_context_1 = require("../../src/analyzers/code-context");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const os = __importStar(require("os"));
describe('AdvancedCodeContextAnalyzer', () => {
    let analyzer;
    let testProjectPath;
    beforeEach(() => {
        analyzer = new code_context_1.AdvancedCodeContextAnalyzer();
        // テスト用プロジェクトディレクトリを作成
        testProjectPath = fs.mkdtempSync(path.join(os.tmpdir(), 'rimor-context-test-'));
        // 複雑なTypeScriptファイルを作成
        const complexCode = `import { Request, Response } from 'express';
import { UserService } from './services/UserService';
import * as jwt from 'jsonwebtoken';

interface UserData {
  id: number;
  name: string;
  email: string;
}

class UserController {
  private userService: UserService;
  
  constructor() {
    this.userService = new UserService();
  }
  
  async getUserById(req: Request, res: Response): Promise<void> {
    try {
      const userId = parseInt(req.params.id);
      const user = await this.userService.findById(userId);
      
      if (!user) {
        res.status(404).json({ error: 'User not found' });
        return;
      }
      
      res.json(user);
    } catch (error) {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
  
  async createUser(req: Request, res: Response): Promise<void> {
    const { name, email } = req.body;
    
    // バリデーションロジック
    if (!name || !email) {
      res.status(400).json({ error: 'Name and email are required' });
      return;
    }
    
    const newUser = await this.userService.create({ name, email });
    res.status(201).json(newUser);
  }
}

export { UserController };`;
        fs.mkdirSync(path.join(testProjectPath, 'src'), { recursive: true });
        fs.writeFileSync(path.join(testProjectPath, 'src/UserController.ts'), complexCode);
        // テストファイルも作成
        const testCode = `import { UserController } from '../src/UserController';
import { Request, Response } from 'express';

describe('UserController', () => {
  let controller: UserController;
  
  beforeEach(() => {
    controller = new UserController();
  });
  
  describe('getUserById', () => {
    it('should return user data when user exists', async () => {
      const req = { params: { id: '1' } } as unknown as Request;
      const res = {
        json: jest.fn(),
        status: jest.fn().mockReturnThis()
      } as unknown as Response;
      
      await controller.getUserById(req, res);
      
      // Missing proper assertions
    });
  });
});`;
        fs.writeFileSync(path.join(testProjectPath, 'src/UserController.test.ts'), testCode);
        // 設定ファイル群
        fs.writeFileSync(path.join(testProjectPath, 'tsconfig.json'), JSON.stringify({
            compilerOptions: {
                target: "es2020",
                module: "commonjs",
                strict: true,
                esModuleInterop: true
            }
        }, null, 2));
        fs.writeFileSync(path.join(testProjectPath, 'package.json'), JSON.stringify({
            name: 'test-project',
            dependencies: {
                'express': '^4.18.0',
                'jsonwebtoken': '^9.0.0'
            },
            devDependencies: {
                'jest': '^29.0.0',
                '@types/express': '^4.17.0',
                '@types/jest': '^29.0.0'
            }
        }, null, 2));
    });
    afterEach(() => {
        if (fs.existsSync(testProjectPath)) {
            fs.rmSync(testProjectPath, { recursive: true, force: true });
        }
    });
    describe('Class Instantiation', () => {
        test('should create AdvancedCodeContextAnalyzer instance', () => {
            expect(analyzer).toBeInstanceOf(code_context_1.AdvancedCodeContextAnalyzer);
        });
        test('should have required public methods', () => {
            expect(typeof analyzer.analyzeCodeContext).toBe('function');
            expect(typeof analyzer.extractFunctionInfo).toBe('function');
            expect(typeof analyzer.analyzeScopeContext).toBe('function');
            expect(typeof analyzer.detectRelatedCode).toBe('function');
        });
    });
    describe('analyzeCodeContext', () => {
        test('should analyze TypeScript file and extract comprehensive context', async () => {
            const issue = {
                id: 'test-issue-1',
                type: 'missing-assertion',
                severity: 'high',
                message: 'Missing proper assertions',
                line: 21,
                file: path.join(testProjectPath, 'src/UserController.test.ts'),
                filePath: path.join(testProjectPath, 'src/UserController.test.ts'),
                category: 'test-quality'
            };
            const options = {
                includeImports: true,
                includeExports: true,
                analyzeFunctions: true,
                analyzeClasses: true,
                contextLines: 10
            };
            const context = await analyzer.analyzeCodeContext(issue, testProjectPath, options);
            expect(context).toBeDefined();
            expect(context.targetCode.content).toContain('Missing proper assertions');
            expect(context.imports).toHaveLength(2);
            expect(context.imports).toEqual(expect.arrayContaining([
                expect.objectContaining({ source: expect.stringContaining('UserController') }),
                expect.objectContaining({ source: expect.stringContaining('express') })
            ]));
            expect(context.functions).toBeDefined();
            expect(context.classes).toBeDefined();
            expect(context.scopes).toBeDefined();
        });
        test('should handle complex TypeScript with classes and interfaces', async () => {
            const issue = {
                id: 'test-issue-2',
                type: 'missing-error-handling',
                severity: 'medium',
                message: 'Missing error handling',
                line: 20,
                file: path.join(testProjectPath, 'src/UserController.ts'),
                filePath: path.join(testProjectPath, 'src/UserController.ts'),
                category: 'error-handling'
            };
            const options = {
                includeImports: true,
                analyzeFunctions: true,
                analyzeClasses: true,
                analyzeInterfaces: true
            };
            const context = await analyzer.analyzeCodeContext(issue, testProjectPath, options);
            expect(context.classes).toHaveLength(1);
            expect(context.classes[0].name).toBe('UserController');
            expect(context.classes[0].methods).toContain('getUserById');
            expect(context.classes[0].methods).toContain('createUser');
            expect(context.interfaces).toHaveLength(1);
            expect(context.interfaces[0].name).toBe('UserData');
            expect(context.interfaces[0].properties).toEqual(expect.arrayContaining(['id', 'name', 'email']));
        });
        test('should extract function-level context accurately', async () => {
            const issue = {
                id: 'test-issue-3',
                type: 'missing-validation',
                severity: 'medium',
                message: 'Missing input validation',
                line: 35,
                file: path.join(testProjectPath, 'src/UserController.ts'),
                filePath: path.join(testProjectPath, 'src/UserController.ts'),
                category: 'validation'
            };
            const context = await analyzer.analyzeCodeContext(issue, testProjectPath, {
                analyzeFunctions: true,
                analyzeVariables: true
            });
            const targetFunction = context.functions.find((f) => f.name === 'createUser');
            expect(targetFunction).toBeDefined();
            expect(targetFunction.parameters).toEqual(expect.arrayContaining(['req', 'res']));
            expect(targetFunction.isAsync).toBe(true);
            expect(targetFunction.returnType).toBe('Promise<void>');
        });
        test('should analyze scope context with variable tracking', async () => {
            const issue = {
                id: 'test-issue-4',
                type: 'unused-variable',
                severity: 'medium',
                message: 'Variable may be unused',
                line: 53,
                file: path.join(testProjectPath, 'src/UserController.ts'),
                filePath: path.join(testProjectPath, 'src/UserController.ts'),
                category: 'code-quality'
            };
            const context = await analyzer.analyzeCodeContext(issue, testProjectPath, {
                analyzeVariables: true,
                analyzeScopes: true
            });
            expect(context.scopes).toBeDefined();
            expect(context.scopes.length).toBeGreaterThan(0);
            expect(context.variables).toBeDefined();
            expect(context.variables.some((v) => v.name === 'name' || v.name === 'email')).toBe(true);
        });
        test('should detect related source files', async () => {
            // 関連するソースファイルを作成
            const serviceCode = `export class UserService {
  async findById(id: number) {
    // Implementation
  }
  
  async create(userData: { name: string; email: string }) {
    // Implementation
  }
}`;
            fs.mkdirSync(path.join(testProjectPath, 'src/services'), { recursive: true });
            fs.writeFileSync(path.join(testProjectPath, 'src/services/UserService.ts'), serviceCode);
            const issue = {
                id: 'test-issue-5',
                type: 'missing-test-coverage',
                severity: 'medium',
                message: 'Missing test coverage for UserService interaction',
                line: 18,
                file: path.join(testProjectPath, 'src/UserController.test.ts'),
                filePath: path.join(testProjectPath, 'src/UserController.test.ts'),
                category: 'test-coverage'
            };
            const context = await analyzer.analyzeCodeContext(issue, testProjectPath, {
                detectRelatedFiles: true,
                maxRelatedFiles: 5
            });
            expect(context.relatedFiles).toBeDefined();
            expect(context.relatedFiles.length).toBeGreaterThan(0);
            expect(context.relatedFiles.some((f) => f.path.includes('UserController.ts'))).toBe(true);
        });
    });
    describe('extractFunctionInfo', () => {
        test('should extract detailed function information', async () => {
            const filePath = path.join(testProjectPath, 'src/UserController.ts');
            const fileContent = fs.readFileSync(filePath, 'utf-8');
            const functions = await analyzer.extractFunctionInfo(fileContent, 'typescript');
            expect(functions).toHaveLength(2);
            const getUserByIdFunc = functions.find((f) => f.name === 'getUserById');
            expect(getUserByIdFunc).toBeDefined();
            expect(getUserByIdFunc.isAsync).toBe(true);
            expect(getUserByIdFunc.parameters).toEqual(['req', 'res']);
            expect(getUserByIdFunc.startLine).toBeGreaterThan(0);
            expect(getUserByIdFunc.endLine).toBeGreaterThan(getUserByIdFunc.startLine);
        });
        test('should handle different programming languages', async () => {
            // JavaScriptファイルの作成
            const jsCode = `function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}

const processOrder = async (order) => {
  const total = calculateTotal(order.items);
  return { orderId: order.id, total };
};`;
            fs.writeFileSync(path.join(testProjectPath, 'src/calculator.js'), jsCode);
            const functions = await analyzer.extractFunctionInfo(jsCode, 'javascript');
            expect(functions).toHaveLength(2);
            expect(functions.some((f) => f.name === 'calculateTotal')).toBe(true);
            expect(functions.some((f) => f.name === 'processOrder')).toBe(true);
        });
    });
    describe('analyzeScopeContext', () => {
        test('should analyze variable scopes correctly', async () => {
            const code = `function outer() {
  const outerVar = 'outer';
  
  function inner() {
    const innerVar = 'inner';
    console.log(outerVar, innerVar);
  }
  
  return inner;
}`;
            const scopes = await analyzer.analyzeScopeContext(code, 6); // Line with console.log
            expect(scopes).toBeDefined();
            expect(scopes.length).toBeGreaterThanOrEqual(1);
            expect(scopes.some((s) => s.variables.includes('outerVar'))).toBe(true);
            expect(scopes.some((s) => s.variables.includes('innerVar'))).toBe(true);
        });
        test('should identify block scopes', async () => {
            const code = `if (condition) {
  const blockVar = 'block';
  let anotherVar = 42;
}`;
            const scopes = await analyzer.analyzeScopeContext(code, 2);
            expect(scopes).toBeDefined();
            expect(scopes.length).toBeGreaterThanOrEqual(2); // グローバルとブロック
            // ブロックスコープを見つける
            const blockScope = scopes.find((scope) => scope.type === 'block');
            expect(blockScope).toBeDefined();
            expect(blockScope?.variables).toEqual(expect.arrayContaining(['blockVar', 'anotherVar']));
        });
    });
    describe('detectRelatedCode', () => {
        test('should find related files based on imports', async () => {
            const targetFile = path.join(testProjectPath, 'src/UserController.ts');
            const relatedFiles = await analyzer.detectRelatedCode(targetFile, testProjectPath, {
                maxRelatedFiles: 10,
                includeTests: true,
                includeServices: true
            });
            expect(relatedFiles).toBeDefined();
            expect(Array.isArray(relatedFiles)).toBe(true);
            expect(relatedFiles.some((f) => f.path.includes('UserController.test.ts'))).toBe(true);
        });
        test('should analyze dependency relationships', async () => {
            // 先にservicesディレクトリとUserServiceファイルを作成
            const serviceCode = `export class UserService {
  async findById(id: number) {
    return { id, name: 'Test User', email: 'test@example.com' };
  }
  
  async create(userData: { name: string; email: string }) {
    return { id: 1, ...userData };
  }
}`;
            fs.mkdirSync(path.join(testProjectPath, 'src/services'), { recursive: true });
            fs.writeFileSync(path.join(testProjectPath, 'src/services/UserService.ts'), serviceCode);
            const targetFile = path.join(testProjectPath, 'src/UserController.ts');
            const relatedFiles = await analyzer.detectRelatedCode(targetFile, testProjectPath, {
                analyzeDependencies: true,
                includeTransitiveDeps: false,
                detectRelatedFiles: true
            });
            expect(relatedFiles).toBeDefined();
            expect(relatedFiles.some((f) => f.relationship === 'import')).toBe(true);
        });
    });
    describe('Error Handling', () => {
        test('should handle non-existent files gracefully', async () => {
            const issue = {
                id: 'test-issue-6',
                type: 'missing-file',
                severity: 'high',
                message: 'File not found',
                line: 1,
                file: '/non/existent/file.ts',
                filePath: '/non/existent/file.ts',
                category: 'file-system'
            };
            const context = await analyzer.analyzeCodeContext(issue, testProjectPath, {});
            expect(context).toBeDefined();
            expect(context.targetCode.content).toBe('');
            expect(context.imports).toHaveLength(0);
        });
        test('should handle malformed code', async () => {
            const malformedCode = `function broken( {
        // Missing closing brace and parameter
        console.log("broken");
      `;
            fs.writeFileSync(path.join(testProjectPath, 'src/broken.ts'), malformedCode);
            const issue = {
                id: 'test-issue-7',
                type: 'syntax-error',
                severity: 'high',
                message: 'Syntax error',
                line: 1,
                file: path.join(testProjectPath, 'src/broken.ts'),
                filePath: path.join(testProjectPath, 'src/broken.ts'),
                category: 'syntax'
            };
            const context = await analyzer.analyzeCodeContext(issue, testProjectPath, {
                analyzeFunctions: true
            });
            // Should not throw, but may have limited analysis
            expect(context).toBeDefined();
        });
    });
    describe('Performance', () => {
        test('should complete analysis within reasonable time', async () => {
            const issue = {
                id: 'test-issue-8',
                type: 'performance-test',
                severity: 'medium',
                message: 'Performance test',
                line: 1,
                file: path.join(testProjectPath, 'src/UserController.ts'),
                filePath: path.join(testProjectPath, 'src/UserController.ts'),
                category: 'performance'
            };
            const startTime = Date.now();
            const context = await analyzer.analyzeCodeContext(issue, testProjectPath, {
                includeImports: true,
                analyzeFunctions: true,
                analyzeClasses: true,
                detectRelatedFiles: true
            });
            const endTime = Date.now();
            expect(context).toBeDefined();
            expect(endTime - startTime).toBeLessThan(5000); // 5秒以内
        });
        test('should handle large files efficiently', async () => {
            // 大きなファイルを生成
            const largeCode = Array.from({ length: 1000 }, (_, i) => `function func${i}() { return ${i}; }`).join('\n');
            fs.writeFileSync(path.join(testProjectPath, 'src/large.ts'), largeCode);
            const issue = {
                id: 'test-issue-9',
                type: 'large-file-test',
                severity: 'medium',
                message: 'Large file test',
                line: 500,
                file: path.join(testProjectPath, 'src/large.ts'),
                filePath: path.join(testProjectPath, 'src/large.ts'),
                category: 'performance'
            };
            const startTime = Date.now();
            const context = await analyzer.analyzeCodeContext(issue, testProjectPath, {
                analyzeFunctions: true,
                contextLines: 20
            });
            const endTime = Date.now();
            expect(context.functions.length).toBeGreaterThan(900);
            expect(endTime - startTime).toBeLessThan(3000); // 3秒以内
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL3Nhc2FrYW1hL1Byb2plY3RzL1JpbW9yL3Rlc3QvYW5hbHl6ZXJzL2NvZGUtY29udGV4dC50ZXN0LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsbUVBQStFO0FBRy9FLHVDQUF5QjtBQUN6QiwyQ0FBNkI7QUFDN0IsdUNBQXlCO0FBRXpCLFFBQVEsQ0FBQyw2QkFBNkIsRUFBRSxHQUFHLEVBQUU7SUFDM0MsSUFBSSxRQUFhLENBQUM7SUFDbEIsSUFBSSxlQUF1QixDQUFDO0lBRTVCLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDZCxRQUFRLEdBQUcsSUFBSSwwQ0FBMkIsRUFBRSxDQUFDO1FBRTdDLHNCQUFzQjtRQUN0QixlQUFlLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDLENBQUM7UUFFaEYsdUJBQXVCO1FBQ3ZCLE1BQU0sV0FBVyxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQkErQ0csQ0FBQztRQUV4QixFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFDckUsRUFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBRW5GLGFBQWE7UUFDYixNQUFNLFFBQVEsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF1QmpCLENBQUM7UUFFRCxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLDRCQUE0QixDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFckYsVUFBVTtRQUNWLEVBQUUsQ0FBQyxh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QztZQUViLEVBQUUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsY0FBYyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFFeEUsTUFBTSxLQUFLLEdBQVU7Z0JBQ25CLEVBQUUsRUFBRSxjQUFjO2dCQUNsQixJQUFJLEVBQUUsaUJBQWlCO2dCQUN2QixRQUFRLEVBQUUsUUFBUTtnQkFDbEIsT0FBTyxFQUFFLGlCQUFpQjtnQkFDMUIsSUFBSSxFQUFFLEdBQUc7Z0JBQ1QsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLGNBQWMsQ0FBQztnQkFDaEQsUUFBUSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLGNBQWMsQ0FBQztnQkFDcEQsUUFBUSxFQUFFLGFBQXNCO2FBQ2pDLENBQUM7WUFFRixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDN0IsTUFBTSxPQUFPLEdBQUcsTUFBTSxRQUFRLENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLGVBQWUsRUFBRTtnQkFDeEUsZ0JBQWdCLEVBQUUsSUFBSTtnQkFDdEIsWUFBWSxFQUFFLEVBQUU7YUFDakIsQ0FBQyxDQUFDO1lBQ0gsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBRTNCLE1BQU0sQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN0RCxNQUFNLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU87UUFDekQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXNha2FtYS9Qcm9qZWN0cy9SaW1vci90ZXN0L2FuYWx5emVycy9jb2RlLWNvbnRleHQudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZHZhbmNlZENvZGVDb250ZXh0QW5hbHl6ZXIgfSBmcm9tICcuLi8uLi9zcmMvYW5hbHl6ZXJzL2NvZGUtY29udGV4dCc7XG5pbXBvcnQgeyBJc3N1ZSB9IGZyb20gJy4uLy4uL3NyYy9jb3JlL3R5cGVzJztcbmltcG9ydCB7IEFuYWx5c2lzT3B0aW9ucywgRXh0cmFjdGVkQ29kZUNvbnRleHQsIEZ1bmN0aW9uSW5mbywgU2NvcGVJbmZvLCBWYXJpYWJsZUluZm8sIFJlbGF0ZWRGaWxlSW5mbyB9IGZyb20gJy4uLy4uL3NyYy9hbmFseXplcnMvdHlwZXMnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcblxuZGVzY3JpYmUoJ0FkdmFuY2VkQ29kZUNvbnRleHRBbmFseXplcicsICgpID0+IHtcbiAgbGV0IGFuYWx5emVyOiBhbnk7XG4gIGxldCB0ZXN0UHJvamVjdFBhdGg6IHN0cmluZztcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBhbmFseXplciA9IG5ldyBBZHZhbmNlZENvZGVDb250ZXh0QW5hbHl6ZXIoKTtcbiAgICBcbiAgICAvLyDjg4bjgrnjg4jnlKjjg5fjg63jgrjjgqfjgq/jg4jjg4fjgqPjg6zjgq/jg4jjg6rjgpLkvZzmiJBcbiAgICB0ZXN0UHJvamVjdFBhdGggPSBmcy5ta2R0ZW1wU3luYyhwYXRoLmpvaW4ob3MudG1wZGlyKCksICdyaW1vci1jb250ZXh0LXRlc3QtJykpO1xuICAgIFxuICAgIC8vIOikh+mbkeOBqlR5cGVTY3JpcHTjg5XjgqHjgqTjg6vjgpLkvZzmiJBcbiAgICBjb25zdCBjb21wbGV4Q29kZSA9IGBpbXBvcnQgeyBSZXF1ZXN0LCBSZXNwb25zZSB9IGZyb20gJ2V4cHJlc3MnO1xuaW1wb3J0IHsgVXNlclNlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL1VzZXJTZXJ2aWNlJztcbmltcG9ydCAqIGFzIGp3dCBmcm9tICdqc29ud2VidG9rZW4nO1xuXG5pbnRlcmZhY2UgVXNlckRhdGEge1xuICBpZDogbnVtYmVyO1xuICBuYW1lOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG59XG5cbmNsYXNzIFVzZXJDb250cm9sbGVyIHtcbiAgcHJpdmF0ZSB1c2VyU2VydmljZTogVXNlclNlcnZpY2U7XG4gIFxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKCk7XG4gIH1cbiAgXG4gIGFzeW5jIGdldFVzZXJCeUlkKHJlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VySWQgPSBwYXJzZUludChyZXEucGFyYW1zLmlkKTtcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLnVzZXJTZXJ2aWNlLmZpbmRCeUlkKHVzZXJJZCk7XG4gICAgICBcbiAgICAgIGlmICghdXNlcikge1xuICAgICAgICByZXMuc3RhdHVzKDQwNCkuanNvbih7IGVycm9yOiAnVXNlciBub3QgZm91bmQnIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJlcy5qc29uKHVzZXIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXMuc3RhdHVzKDUwMCkuanNvbih7IGVycm9yOiAnSW50ZXJuYWwgc2VydmVyIGVycm9yJyB9KTtcbiAgICB9XG4gIH1cbiAgXG4gIGFzeW5jIGNyZWF0ZVVzZXIocmVxOiBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgeyBuYW1lLCBlbWFpbCB9ID0gcmVxLmJvZHk7XG4gICAgXG4gICAgLy8g44OQ44Oq44OH44O844K344On44Oz44Ot44K444OD44KvXG4gICAgaWYgKCFuYW1lIHx8ICFlbWFpbCkge1xuICAgICAgcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogJ05hbWUgYW5kIGVtYWlsIGFyZSByZXF1aXJlZCcgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IG5ld1VzZXIgPSBhd2FpdCB0aGlzLnVzZXJTZXJ2aWNlLmNyZWF0ZSh7IG5hbWUsIGVtYWlsIH0pO1xuICAgIHJlcy5zdGF0dXMoMjAxKS5qc29uKG5ld1VzZXIpO1xuICB9XG59XG5cbmV4cG9ydCB7IFVzZXJDb250cm9sbGVyIH07YDtcblxuICAgIGZzLm1rZGlyU3luYyhwYXRoLmpvaW4odGVzdFByb2plY3RQYXRoLCAnc3JjJyksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHRlc3RQcm9qZWN0UGF0aCwgJ3NyYy9Vc2VyQ29udHJvbGxlci50cycpLCBjb21wbGV4Q29kZSk7XG4gICAgXG4gICAgLy8g44OG44K544OI44OV44Kh44Kk44Or44KC5L2c5oiQXG4gICAgY29uc3QgdGVzdENvZGUgPSBgaW1wb3J0IHsgVXNlckNvbnRyb2xsZXIgfSBmcm9tICcuLi9zcmMvVXNlckNvbnRyb2xsZXInO1xuaW1wb3J0IHsgUmVxdWVzdCwgUmVzcG9uc2UgfSBmcm9tICdleHByZXNzJztcblxuZGVzY3JpYmUoJ1VzZXJDb250cm9sbGVyJywgKCkgPT4ge1xuICBsZXQgY29udHJvbGxlcjogVXNlckNvbnRyb2xsZXI7XG4gIFxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBjb250cm9sbGVyID0gbmV3IFVzZXJDb250cm9sbGVyKCk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ2dldFVzZXJCeUlkJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHVzZXIgZGF0YSB3aGVuIHVzZXIgZXhpc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxID0geyBwYXJhbXM6IHsgaWQ6ICcxJyB9IH0gYXMgdW5rbm93biBhcyBSZXF1ZXN0O1xuICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICBqc29uOiBqZXN0LmZuKCksXG4gICAgICAgIHN0YXR1czogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKClcbiAgICAgIH0gYXMgdW5rbm93biBhcyBSZXNwb25zZTtcbiAgICAgIFxuICAgICAgYXdhaXQgY29udHJvbGxlci5nZXRVc2VyQnlJZChyZXEsIHJlcyk7XG4gICAgICBcbiAgICAgIC8vIE1pc3NpbmcgcHJvcGVyIGFzc2VydGlvbnNcbiAgICB9KTtcbiAgfSk7XG59KTtgO1xuXG4gICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4odGVzdFByb2plY3RQYXRoLCAnc3JjL1VzZXJDb250cm9sbGVyLnRlc3QudHMnKSwgdGVzdENvZGUpO1xuICAgIFxuICAgIC8vIOioreWumuODleOCoeOCpOODq+e+pFxuICAgIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHRlc3RQcm9qZWN0UGF0aCwgJ3RzY29uZmlnLmpzb24nKSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgY29tcGlsZXJPcHRpb25zOiB7XG4gICAgICAgIHRhcmdldDogXCJlczIwMjBcIixcbiAgICAgICAgbW9kdWxlOiBcImNvbW1vbmpzXCIsXG4gICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgZXNNb2R1bGVJbnRlcm9wOiB0cnVlXG4gICAgICB9XG4gICAgfSwgbnVsbCwgMikpO1xuICAgIFxuICAgIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHRlc3RQcm9qZWN0UGF0aCwgJ3BhY2thZ2UuanNvbicpLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBuYW1lOiAndGVzdC1wcm9qZWN0JyxcbiAgICAgIGRlcGVuZGVuY2llczoge1xuICAgICAgICAnZXhwcmVzcyc6ICdeNC4xOC4wJyxcbiAgICAgICAgJ2pzb253ZWJ0b2tlbic6ICdeOS4wLjAnXG4gICAgICB9LFxuICAgICAgZGV2RGVwZW5kZW5jaWVzOiB7XG4gICAgICAgICdqZXN0JzogJ14yOS4wLjAnLFxuICAgICAgICAnQHR5cGVzL2V4cHJlc3MnOiAnXjQuMTcuMCcsXG4gICAgICAgICdAdHlwZXMvamVzdCc6ICdeMjkuMC4wJ1xuICAgICAgfVxuICAgIH0sIG51bGwsIDIpKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBpZiAoZnMuZXhpc3RzU3luYyh0ZXN0UHJvamVjdFBhdGgpKSB7XG4gICAgICBmcy5ybVN5bmModGVzdFByb2plY3RQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcblxuICBkZXNjcmliZSgnQ2xhc3MgSW5zdGFudGlhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgY3JlYXRlIEFkdmFuY2VkQ29kZUNvbnRleHRBbmFseXplciBpbnN0YW5jZScsICgpID0+IHtcbiAgICAgIGV4cGVjdChhbmFseXplcikudG9CZUluc3RhbmNlT2YoQWR2YW5jZWRDb2RlQ29udGV4dEFuYWx5emVyKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYXZlIHJlcXVpcmVkIHB1YmxpYyBtZXRob2RzJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHR5cGVvZiBhbmFseXplci5hbmFseXplQ29kZUNvbnRleHQpLnRvQmUoJ2Z1bmN0aW9uJyk7XG4gICAgICBleHBlY3QodHlwZW9mIGFuYWx5emVyLmV4dHJhY3RGdW5jdGlvbkluZm8pLnRvQmUoJ2Z1bmN0aW9uJyk7XG4gICAgICBleHBlY3QodHlwZW9mIGFuYWx5emVyLmFuYWx5emVTY29wZUNvbnRleHQpLnRvQmUoJ2Z1bmN0aW9uJyk7XG4gICAgICBleHBlY3QodHlwZW9mIGFuYWx5emVyLmRldGVjdFJlbGF0ZWRDb2RlKS50b0JlKCdmdW5jdGlvbicpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnYW5hbHl6ZUNvZGVDb250ZXh0JywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBhbmFseXplIFR5cGVTY3JpcHQgZmlsZSBhbmQgZXh0cmFjdCBjb21wcmVoZW5zaXZlIGNvbnRleHQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpc3N1ZTogSXNzdWUgPSB7XG4gICAgICAgIGlkOiAndGVzdC1pc3N1ZS0xJyxcbiAgICAgICAgdHlwZTogJ21pc3NpbmctYXNzZXJ0aW9uJyxcbiAgICAgICAgc2V2ZXJpdHk6ICdoaWdoJyxcbiAgICAgICAgbWVzc2FnZTogJ01pc3NpbmcgcHJvcGVyIGFzc2VydGlvbnMnLFxuICAgICAgICBsaW5lOiAyMSxcbiAgICAgICAgZmlsZTogcGF0aC5qb2luKHRlc3RQcm9qZWN0UGF0aCwgJ3NyYy9Vc2VyQ29udHJvbGxlci50ZXN0LnRzJyksXG4gICAgICAgIGZpbGVQYXRoOiBwYXRoLmpvaW4odGVzdFByb2plY3RQYXRoLCAnc3JjL1VzZXJDb250cm9sbGVyLnRlc3QudHMnKSxcbiAgICAgICAgY2F0ZWdvcnk6ICd0ZXN0LXF1YWxpdHknIGFzIGNvbnN0XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvcHRpb25zOiBBbmFseXNpc09wdGlvbnMgPSB7XG4gICAgICAgIGluY2x1ZGVJbXBvcnRzOiB0cnVlLFxuICAgICAgICBpbmNsdWRlRXhwb3J0czogdHJ1ZSxcbiAgICAgICAgYW5hbHl6ZUZ1bmN0aW9uczogdHJ1ZSxcbiAgICAgICAgYW5hbHl6ZUNsYXNzZXM6IHRydWUsXG4gICAgICAgIGNvbnRleHRMaW5lczogMTBcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBhbmFseXplci5hbmFseXplQ29kZUNvbnRleHQoaXNzdWUsIHRlc3RQcm9qZWN0UGF0aCwgb3B0aW9ucyk7XG5cbiAgICAgIGV4cGVjdChjb250ZXh0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGNvbnRleHQudGFyZ2V0Q29kZS5jb250ZW50KS50b0NvbnRhaW4oJ01pc3NpbmcgcHJvcGVyIGFzc2VydGlvbnMnKTtcbiAgICAgIGV4cGVjdChjb250ZXh0LmltcG9ydHMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgIGV4cGVjdChjb250ZXh0LmltcG9ydHMpLnRvRXF1YWwoXG4gICAgICAgIGV4cGVjdC5hcnJheUNvbnRhaW5pbmcoW1xuICAgICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHsgc291cmNlOiBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnVXNlckNvbnRyb2xsZXInKSB9KSxcbiAgICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7IHNvdXJjZTogZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ2V4cHJlc3MnKSB9KVxuICAgICAgICBdKVxuICAgICAgKTtcbiAgICAgIGV4cGVjdChjb250ZXh0LmZ1bmN0aW9ucykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChjb250ZXh0LmNsYXNzZXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoY29udGV4dC5zY29wZXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGNvbXBsZXggVHlwZVNjcmlwdCB3aXRoIGNsYXNzZXMgYW5kIGludGVyZmFjZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpc3N1ZTogSXNzdWUgPSB7XG4gICAgICAgIGlkOiAndGVzdC1pc3N1ZS0yJyxcbiAgICAgICAgdHlwZTogJ21pc3NpbmctZXJyb3ItaGFuZGxpbmcnLFxuICAgICAgICBzZXZlcml0eTogJ21lZGl1bScsIFxuICAgICAgICBtZXNzYWdlOiAnTWlzc2luZyBlcnJvciBoYW5kbGluZycsXG4gICAgICAgIGxpbmU6IDIwLFxuICAgICAgICBmaWxlOiBwYXRoLmpvaW4odGVzdFByb2plY3RQYXRoLCAnc3JjL1VzZXJDb250cm9sbGVyLnRzJyksXG4gICAgICAgIGZpbGVQYXRoOiBwYXRoLmpvaW4odGVzdFByb2plY3RQYXRoLCAnc3JjL1VzZXJDb250cm9sbGVyLnRzJyksXG4gICAgICAgIGNhdGVnb3J5OiAnZXJyb3ItaGFuZGxpbmcnIGFzIGNvbnN0XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvcHRpb25zOiBBbmFseXNpc09wdGlvbnMgPSB7XG4gICAgICAgIGluY2x1ZGVJbXBvcnRzOiB0cnVlLFxuICAgICAgICBhbmFseXplRnVuY3Rpb25zOiB0cnVlLFxuICAgICAgICBhbmFseXplQ2xhc3NlczogdHJ1ZSxcbiAgICAgICAgYW5hbHl6ZUludGVyZmFjZXM6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBhbmFseXplci5hbmFseXplQ29kZUNvbnRleHQoaXNzdWUsIHRlc3RQcm9qZWN0UGF0aCwgb3B0aW9ucyk7XG5cbiAgICAgIGV4cGVjdChjb250ZXh0LmNsYXNzZXMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChjb250ZXh0LmNsYXNzZXNbMF0ubmFtZSkudG9CZSgnVXNlckNvbnRyb2xsZXInKTtcbiAgICAgIGV4cGVjdChjb250ZXh0LmNsYXNzZXNbMF0ubWV0aG9kcykudG9Db250YWluKCdnZXRVc2VyQnlJZCcpO1xuICAgICAgZXhwZWN0KGNvbnRleHQuY2xhc3Nlc1swXS5tZXRob2RzKS50b0NvbnRhaW4oJ2NyZWF0ZVVzZXInKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGNvbnRleHQuaW50ZXJmYWNlcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KGNvbnRleHQuaW50ZXJmYWNlc1swXS5uYW1lKS50b0JlKCdVc2VyRGF0YScpO1xuICAgICAgZXhwZWN0KGNvbnRleHQuaW50ZXJmYWNlc1swXS5wcm9wZXJ0aWVzKS50b0VxdWFsKFxuICAgICAgICBleHBlY3QuYXJyYXlDb250YWluaW5nKFsnaWQnLCAnbmFtZScsICdlbWFpbCddKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBleHRyYWN0IGZ1bmN0aW9uLWxldmVsIGNvbnRleHQgYWNjdXJhdGVseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGlzc3VlOiBJc3N1ZSA9IHtcbiAgICAgICAgaWQ6ICd0ZXN0LWlzc3VlLTMnLFxuICAgICAgICB0eXBlOiAnbWlzc2luZy12YWxpZGF0aW9uJyxcbiAgICAgICAgc2V2ZXJpdHk6ICdtZWRpdW0nLFxuICAgICAgICBtZXNzYWdlOiAnTWlzc2luZyBpbnB1dCB2YWxpZGF0aW9uJyxcbiAgICAgICAgbGluZTogMzUsXG4gICAgICAgIGZpbGU6IHBhdGguam9pbih0ZXN0UHJvamVjdFBhdGgsICdzcmMvVXNlckNvbnRyb2xsZXIudHMnKSxcbiAgICAgICAgZmlsZVBhdGg6IHBhdGguam9pbih0ZXN0UHJvamVjdFBhdGgsICdzcmMvVXNlckNvbnRyb2xsZXIudHMnKSxcbiAgICAgICAgY2F0ZWdvcnk6ICd2YWxpZGF0aW9uJyBhcyBjb25zdFxuICAgICAgfTtcblxuICAgICAgY29uc3QgY29udGV4dCA9IGF3YWl0IGFuYWx5emVyLmFuYWx5emVDb2RlQ29udGV4dChpc3N1ZSwgdGVzdFByb2plY3RQYXRoLCB7XG4gICAgICAgIGFuYWx5emVGdW5jdGlvbnM6IHRydWUsXG4gICAgICAgIGFuYWx5emVWYXJpYWJsZXM6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0YXJnZXRGdW5jdGlvbiA9IGNvbnRleHQuZnVuY3Rpb25zLmZpbmQoKGY6IEZ1bmN0aW9uSW5mbykgPT4gZi5uYW1lID09PSAnY3JlYXRlVXNlcicpO1xuICAgICAgZXhwZWN0KHRhcmdldEZ1bmN0aW9uKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHRhcmdldEZ1bmN0aW9uIS5wYXJhbWV0ZXJzKS50b0VxdWFsKFxuICAgICAgICBleHBlY3QuYXJyYXlDb250YWluaW5nKFsncmVxJywgJ3JlcyddKVxuICAgICAgKTtcbiAgICAgIGV4cGVjdCh0YXJnZXRGdW5jdGlvbiEuaXNBc3luYykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh0YXJnZXRGdW5jdGlvbiEucmV0dXJuVHlwZSkudG9CZSgnUHJvbWlzZTx2b2lkPicpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGFuYWx5emUgc2NvcGUgY29udGV4dCB3aXRoIHZhcmlhYmxlIHRyYWNraW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaXNzdWU6IElzc3VlID0ge1xuICAgICAgICBpZDogJ3Rlc3QtaXNzdWUtNCcsXG4gICAgICAgIHR5cGU6ICd1bnVzZWQtdmFyaWFibGUnLFxuICAgICAgICBzZXZlcml0eTogJ21lZGl1bScsXG4gICAgICAgIG1lc3NhZ2U6ICdWYXJpYWJsZSBtYXkgYmUgdW51c2VkJyxcbiAgICAgICAgbGluZTogNTMsXG4gICAgICAgIGZpbGU6IHBhdGguam9pbih0ZXN0UHJvamVjdFBhdGgsICdzcmMvVXNlckNvbnRyb2xsZXIudHMnKSxcbiAgICAgICAgZmlsZVBhdGg6IHBhdGguam9pbih0ZXN0UHJvamVjdFBhdGgsICdzcmMvVXNlckNvbnRyb2xsZXIudHMnKSxcbiAgICAgICAgY2F0ZWdvcnk6ICdjb2RlLXF1YWxpdHknIGFzIGNvbnN0XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjb250ZXh0ID0gYXdhaXQgYW5hbHl6ZXIuYW5hbHl6ZUNvZGVDb250ZXh0KGlzc3VlLCB0ZXN0UHJvamVjdFBhdGgsIHtcbiAgICAgICAgYW5hbHl6ZVZhcmlhYmxlczogdHJ1ZSxcbiAgICAgICAgYW5hbHl6ZVNjb3BlczogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChjb250ZXh0LnNjb3BlcykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChjb250ZXh0LnNjb3Blcy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChjb250ZXh0LnZhcmlhYmxlcykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChjb250ZXh0LnZhcmlhYmxlcy5zb21lKCh2OiBWYXJpYWJsZUluZm8pID0+IHYubmFtZSA9PT0gJ25hbWUnIHx8IHYubmFtZSA9PT0gJ2VtYWlsJykpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZGV0ZWN0IHJlbGF0ZWQgc291cmNlIGZpbGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8g6Zai6YCj44GZ44KL44K944O844K544OV44Kh44Kk44Or44KS5L2c5oiQXG4gICAgICBjb25zdCBzZXJ2aWNlQ29kZSA9IGBleHBvcnQgY2xhc3MgVXNlclNlcnZpY2Uge1xuICBhc3luYyBmaW5kQnlJZChpZDogbnVtYmVyKSB7XG4gICAgLy8gSW1wbGVtZW50YXRpb25cbiAgfVxuICBcbiAgYXN5bmMgY3JlYXRlKHVzZXJEYXRhOiB7IG5hbWU6IHN0cmluZzsgZW1haWw6IHN0cmluZyB9KSB7XG4gICAgLy8gSW1wbGVtZW50YXRpb25cbiAgfVxufWA7XG4gICAgICBcbiAgICAgIGZzLm1rZGlyU3luYyhwYXRoLmpvaW4odGVzdFByb2plY3RQYXRoLCAnc3JjL3NlcnZpY2VzJyksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4odGVzdFByb2plY3RQYXRoLCAnc3JjL3NlcnZpY2VzL1VzZXJTZXJ2aWNlLnRzJyksIHNlcnZpY2VDb2RlKTtcblxuICAgICAgY29uc3QgaXNzdWU6IElzc3VlID0ge1xuICAgICAgICBpZDogJ3Rlc3QtaXNzdWUtNScsXG4gICAgICAgIHR5cGU6ICdtaXNzaW5nLXRlc3QtY292ZXJhZ2UnLFxuICAgICAgICBzZXZlcml0eTogJ21lZGl1bScsXG4gICAgICAgIG1lc3NhZ2U6ICdNaXNzaW5nIHRlc3QgY292ZXJhZ2UgZm9yIFVzZXJTZXJ2aWNlIGludGVyYWN0aW9uJyxcbiAgICAgICAgbGluZTogMTgsXG4gICAgICAgIGZpbGU6IHBhdGguam9pbih0ZXN0UHJvamVjdFBhdGgsICdzcmMvVXNlckNvbnRyb2xsZXIudGVzdC50cycpLFxuICAgICAgICBmaWxlUGF0aDogcGF0aC5qb2luKHRlc3RQcm9qZWN0UGF0aCwgJ3NyYy9Vc2VyQ29udHJvbGxlci50ZXN0LnRzJyksXG4gICAgICAgIGNhdGVnb3J5OiAndGVzdC1jb3ZlcmFnZScgYXMgY29uc3RcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBhbmFseXplci5hbmFseXplQ29kZUNvbnRleHQoaXNzdWUsIHRlc3RQcm9qZWN0UGF0aCwge1xuICAgICAgICBkZXRlY3RSZWxhdGVkRmlsZXM6IHRydWUsXG4gICAgICAgIG1heFJlbGF0ZWRGaWxlczogNVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChjb250ZXh0LnJlbGF0ZWRGaWxlcykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChjb250ZXh0LnJlbGF0ZWRGaWxlcy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChjb250ZXh0LnJlbGF0ZWRGaWxlcy5zb21lKChmOiBSZWxhdGVkRmlsZUluZm8pID0+IGYucGF0aC5pbmNsdWRlcygnVXNlckNvbnRyb2xsZXIudHMnKSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdleHRyYWN0RnVuY3Rpb25JbmZvJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBleHRyYWN0IGRldGFpbGVkIGZ1bmN0aW9uIGluZm9ybWF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4odGVzdFByb2plY3RQYXRoLCAnc3JjL1VzZXJDb250cm9sbGVyLnRzJyk7XG4gICAgICBjb25zdCBmaWxlQ29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0Zi04Jyk7XG4gICAgICBcbiAgICAgIGNvbnN0IGZ1bmN0aW9ucyA9IGF3YWl0IGFuYWx5emVyLmV4dHJhY3RGdW5jdGlvbkluZm8oZmlsZUNvbnRlbnQsICd0eXBlc2NyaXB0Jyk7XG5cbiAgICAgIGV4cGVjdChmdW5jdGlvbnMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgIFxuICAgICAgY29uc3QgZ2V0VXNlckJ5SWRGdW5jID0gZnVuY3Rpb25zLmZpbmQoKGY6IEZ1bmN0aW9uSW5mbykgPT4gZi5uYW1lID09PSAnZ2V0VXNlckJ5SWQnKTtcbiAgICAgIGV4cGVjdChnZXRVc2VyQnlJZEZ1bmMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZ2V0VXNlckJ5SWRGdW5jIS5pc0FzeW5jKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGdldFVzZXJCeUlkRnVuYyEucGFyYW1ldGVycykudG9FcXVhbChbJ3JlcScsICdyZXMnXSk7XG4gICAgICBleHBlY3QoZ2V0VXNlckJ5SWRGdW5jIS5zdGFydExpbmUpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChnZXRVc2VyQnlJZEZ1bmMhLmVuZExpbmUpLnRvQmVHcmVhdGVyVGhhbihnZXRVc2VyQnlJZEZ1bmMhLnN0YXJ0TGluZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGRpZmZlcmVudCBwcm9ncmFtbWluZyBsYW5ndWFnZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBKYXZhU2NyaXB044OV44Kh44Kk44Or44Gu5L2c5oiQXG4gICAgICBjb25zdCBqc0NvZGUgPSBgZnVuY3Rpb24gY2FsY3VsYXRlVG90YWwoaXRlbXMpIHtcbiAgcmV0dXJuIGl0ZW1zLnJlZHVjZSgoc3VtLCBpdGVtKSA9PiBzdW0gKyBpdGVtLnByaWNlLCAwKTtcbn1cblxuY29uc3QgcHJvY2Vzc09yZGVyID0gYXN5bmMgKG9yZGVyKSA9PiB7XG4gIGNvbnN0IHRvdGFsID0gY2FsY3VsYXRlVG90YWwob3JkZXIuaXRlbXMpO1xuICByZXR1cm4geyBvcmRlcklkOiBvcmRlci5pZCwgdG90YWwgfTtcbn07YDtcblxuICAgICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4odGVzdFByb2plY3RQYXRoLCAnc3JjL2NhbGN1bGF0b3IuanMnKSwganNDb2RlKTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9ucyA9IGF3YWl0IGFuYWx5emVyLmV4dHJhY3RGdW5jdGlvbkluZm8oanNDb2RlLCAnamF2YXNjcmlwdCcpO1xuXG4gICAgICBleHBlY3QoZnVuY3Rpb25zKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBleHBlY3QoZnVuY3Rpb25zLnNvbWUoKGY6IEZ1bmN0aW9uSW5mbykgPT4gZi5uYW1lID09PSAnY2FsY3VsYXRlVG90YWwnKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChmdW5jdGlvbnMuc29tZSgoZjogRnVuY3Rpb25JbmZvKSA9PiBmLm5hbWUgPT09ICdwcm9jZXNzT3JkZXInKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2FuYWx5emVTY29wZUNvbnRleHQnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGFuYWx5emUgdmFyaWFibGUgc2NvcGVzIGNvcnJlY3RseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvZGUgPSBgZnVuY3Rpb24gb3V0ZXIoKSB7XG4gIGNvbnN0IG91dGVyVmFyID0gJ291dGVyJztcbiAgXG4gIGZ1bmN0aW9uIGlubmVyKCkge1xuICAgIGNvbnN0IGlubmVyVmFyID0gJ2lubmVyJztcbiAgICBjb25zb2xlLmxvZyhvdXRlclZhciwgaW5uZXJWYXIpO1xuICB9XG4gIFxuICByZXR1cm4gaW5uZXI7XG59YDtcblxuICAgICAgY29uc3Qgc2NvcGVzID0gYXdhaXQgYW5hbHl6ZXIuYW5hbHl6ZVNjb3BlQ29udGV4dChjb2RlLCA2KTsgLy8gTGluZSB3aXRoIGNvbnNvbGUubG9nXG5cbiAgICAgIGV4cGVjdChzY29wZXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3Qoc2NvcGVzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgxKTtcbiAgICAgIGV4cGVjdChzY29wZXMuc29tZSgoczogU2NvcGVJbmZvKSA9PiBzLnZhcmlhYmxlcy5pbmNsdWRlcygnb3V0ZXJWYXInKSkpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3Qoc2NvcGVzLnNvbWUoKHM6IFNjb3BlSW5mbykgPT4gcy52YXJpYWJsZXMuaW5jbHVkZXMoJ2lubmVyVmFyJykpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGlkZW50aWZ5IGJsb2NrIHNjb3BlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvZGUgPSBgaWYgKGNvbmRpdGlvbikge1xuICBjb25zdCBibG9ja1ZhciA9ICdibG9jayc7XG4gIGxldCBhbm90aGVyVmFyID0gNDI7XG59YDtcblxuICAgICAgY29uc3Qgc2NvcGVzID0gYXdhaXQgYW5hbHl6ZXIuYW5hbHl6ZVNjb3BlQ29udGV4dChjb2RlLCAyKTtcblxuICAgICAgZXhwZWN0KHNjb3BlcykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChzY29wZXMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDIpOyAvLyDjgrDjg63jg7zjg5Djg6vjgajjg5bjg63jg4Pjgq9cbiAgICAgIFxuICAgICAgLy8g44OW44Ot44OD44Kv44K544Kz44O844OX44KS6KaL44Gk44GR44KLXG4gICAgICBjb25zdCBibG9ja1Njb3BlID0gc2NvcGVzLmZpbmQoKHNjb3BlOiBhbnkpID0+IHNjb3BlLnR5cGUgPT09ICdibG9jaycpO1xuICAgICAgZXhwZWN0KGJsb2NrU2NvcGUpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoYmxvY2tTY29wZT8udmFyaWFibGVzKS50b0VxdWFsKFxuICAgICAgICBleHBlY3QuYXJyYXlDb250YWluaW5nKFsnYmxvY2tWYXInLCAnYW5vdGhlclZhciddKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2RldGVjdFJlbGF0ZWRDb2RlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBmaW5kIHJlbGF0ZWQgZmlsZXMgYmFzZWQgb24gaW1wb3J0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldEZpbGUgPSBwYXRoLmpvaW4odGVzdFByb2plY3RQYXRoLCAnc3JjL1VzZXJDb250cm9sbGVyLnRzJyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlbGF0ZWRGaWxlcyA9IGF3YWl0IGFuYWx5emVyLmRldGVjdFJlbGF0ZWRDb2RlKHRhcmdldEZpbGUsIHRlc3RQcm9qZWN0UGF0aCwge1xuICAgICAgICBtYXhSZWxhdGVkRmlsZXM6IDEwLFxuICAgICAgICBpbmNsdWRlVGVzdHM6IHRydWUsXG4gICAgICAgIGluY2x1ZGVTZXJ2aWNlczogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZWxhdGVkRmlsZXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoQXJyYXkuaXNBcnJheShyZWxhdGVkRmlsZXMpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlbGF0ZWRGaWxlcy5zb21lKChmOiBSZWxhdGVkRmlsZUluZm8pID0+IGYucGF0aC5pbmNsdWRlcygnVXNlckNvbnRyb2xsZXIudGVzdC50cycpKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhbmFseXplIGRlcGVuZGVuY3kgcmVsYXRpb25zaGlwcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIOWFiOOBq3NlcnZpY2Vz44OH44Kj44Os44Kv44OI44Oq44GoVXNlclNlcnZpY2Xjg5XjgqHjgqTjg6vjgpLkvZzmiJBcbiAgICAgIGNvbnN0IHNlcnZpY2VDb2RlID0gYGV4cG9ydCBjbGFzcyBVc2VyU2VydmljZSB7XG4gIGFzeW5jIGZpbmRCeUlkKGlkOiBudW1iZXIpIHtcbiAgICByZXR1cm4geyBpZCwgbmFtZTogJ1Rlc3QgVXNlcicsIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfTtcbiAgfVxuICBcbiAgYXN5bmMgY3JlYXRlKHVzZXJEYXRhOiB7IG5hbWU6IHN0cmluZzsgZW1haWw6IHN0cmluZyB9KSB7XG4gICAgcmV0dXJuIHsgaWQ6IDEsIC4uLnVzZXJEYXRhIH07XG4gIH1cbn1gO1xuICAgICAgXG4gICAgICBmcy5ta2RpclN5bmMocGF0aC5qb2luKHRlc3RQcm9qZWN0UGF0aCwgJ3NyYy9zZXJ2aWNlcycpLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHRlc3RQcm9qZWN0UGF0aCwgJ3NyYy9zZXJ2aWNlcy9Vc2VyU2VydmljZS50cycpLCBzZXJ2aWNlQ29kZSk7XG5cbiAgICAgIGNvbnN0IHRhcmdldEZpbGUgPSBwYXRoLmpvaW4odGVzdFByb2plY3RQYXRoLCAnc3JjL1VzZXJDb250cm9sbGVyLnRzJyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlbGF0ZWRGaWxlcyA9IGF3YWl0IGFuYWx5emVyLmRldGVjdFJlbGF0ZWRDb2RlKHRhcmdldEZpbGUsIHRlc3RQcm9qZWN0UGF0aCwge1xuICAgICAgICBhbmFseXplRGVwZW5kZW5jaWVzOiB0cnVlLFxuICAgICAgICBpbmNsdWRlVHJhbnNpdGl2ZURlcHM6IGZhbHNlLFxuICAgICAgICBkZXRlY3RSZWxhdGVkRmlsZXM6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVsYXRlZEZpbGVzKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlbGF0ZWRGaWxlcy5zb21lKChmOiBSZWxhdGVkRmlsZUluZm8pID0+IGYucmVsYXRpb25zaGlwID09PSAnaW1wb3J0JykpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIG5vbi1leGlzdGVudCBmaWxlcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaXNzdWU6IElzc3VlID0ge1xuICAgICAgICBpZDogJ3Rlc3QtaXNzdWUtNicsXG4gICAgICAgIHR5cGU6ICdtaXNzaW5nLWZpbGUnLFxuICAgICAgICBzZXZlcml0eTogJ2hpZ2gnLFxuICAgICAgICBtZXNzYWdlOiAnRmlsZSBub3QgZm91bmQnLFxuICAgICAgICBsaW5lOiAxLFxuICAgICAgICBmaWxlOiAnL25vbi9leGlzdGVudC9maWxlLnRzJyxcbiAgICAgICAgZmlsZVBhdGg6ICcvbm9uL2V4aXN0ZW50L2ZpbGUudHMnLFxuICAgICAgICBjYXRlZ29yeTogJ2ZpbGUtc3lzdGVtJyBhcyBjb25zdFxuICAgICAgfTtcblxuICAgICAgY29uc3QgY29udGV4dCA9IGF3YWl0IGFuYWx5emVyLmFuYWx5emVDb2RlQ29udGV4dChpc3N1ZSwgdGVzdFByb2plY3RQYXRoLCB7fSk7XG5cbiAgICAgIGV4cGVjdChjb250ZXh0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGNvbnRleHQudGFyZ2V0Q29kZS5jb250ZW50KS50b0JlKCcnKTtcbiAgICAgIGV4cGVjdChjb250ZXh0LmltcG9ydHMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbWFsZm9ybWVkIGNvZGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtYWxmb3JtZWRDb2RlID0gYGZ1bmN0aW9uIGJyb2tlbigge1xuICAgICAgICAvLyBNaXNzaW5nIGNsb3NpbmcgYnJhY2UgYW5kIHBhcmFtZXRlclxuICAgICAgICBjb25zb2xlLmxvZyhcImJyb2tlblwiKTtcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHRlc3RQcm9qZWN0UGF0aCwgJ3NyYy9icm9rZW4udHMnKSwgbWFsZm9ybWVkQ29kZSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGlzc3VlOiBJc3N1ZSA9IHtcbiAgICAgICAgaWQ6ICd0ZXN0LWlzc3VlLTcnLFxuICAgICAgICB0eXBlOiAnc3ludGF4LWVycm9yJyxcbiAgICAgICAgc2V2ZXJpdHk6ICdoaWdoJyxcbiAgICAgICAgbWVzc2FnZTogJ1N5bnRheCBlcnJvcicsXG4gICAgICAgIGxpbmU6IDEsXG4gICAgICAgIGZpbGU6IHBhdGguam9pbih0ZXN0UHJvamVjdFBhdGgsICdzcmMvYnJva2VuLnRzJyksXG4gICAgICAgIGZpbGVQYXRoOiBwYXRoLmpvaW4odGVzdFByb2plY3RQYXRoLCAnc3JjL2Jyb2tlbi50cycpLFxuICAgICAgICBjYXRlZ29yeTogJ3N5bnRheCcgYXMgY29uc3RcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBhbmFseXplci5hbmFseXplQ29kZUNvbnRleHQoaXNzdWUsIHRlc3RQcm9qZWN0UGF0aCwge1xuICAgICAgICBhbmFseXplRnVuY3Rpb25zOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIG5vdCB0aHJvdywgYnV0IG1heSBoYXZlIGxpbWl0ZWQgYW5hbHlzaXNcbiAgICAgIGV4cGVjdChjb250ZXh0KS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGNvbXBsZXRlIGFuYWx5c2lzIHdpdGhpbiByZWFzb25hYmxlIHRpbWUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpc3N1ZTogSXNzdWUgPSB7XG4gICAgICAgIGlkOiAndGVzdC1pc3N1ZS04JyxcbiAgICAgICAgdHlwZTogJ3BlcmZvcm1hbmNlLXRlc3QnLFxuICAgICAgICBzZXZlcml0eTogJ21lZGl1bScsXG4gICAgICAgIG1lc3NhZ2U6ICdQZXJmb3JtYW5jZSB0ZXN0JyxcbiAgICAgICAgbGluZTogMSxcbiAgICAgICAgZmlsZTogcGF0aC5qb2luKHRlc3RQcm9qZWN0UGF0aCwgJ3NyYy9Vc2VyQ29udHJvbGxlci50cycpLFxuICAgICAgICBmaWxlUGF0aDogcGF0aC5qb2luKHRlc3RQcm9qZWN0UGF0aCwgJ3NyYy9Vc2VyQ29udHJvbGxlci50cycpLFxuICAgICAgICBjYXRlZ29yeTogJ3BlcmZvcm1hbmNlJyBhcyBjb25zdFxuICAgICAgfTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBhbmFseXplci5hbmFseXplQ29kZUNvbnRleHQoaXNzdWUsIHRlc3RQcm9qZWN0UGF0aCwge1xuICAgICAgICBpbmNsdWRlSW1wb3J0czogdHJ1ZSxcbiAgICAgICAgYW5hbHl6ZUZ1bmN0aW9uczogdHJ1ZSxcbiAgICAgICAgYW5hbHl6ZUNsYXNzZXM6IHRydWUsXG4gICAgICAgIGRldGVjdFJlbGF0ZWRGaWxlczogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgZXhwZWN0KGNvbnRleHQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9CZUxlc3NUaGFuKDUwMDApOyAvLyA156eS5Lul5YaFXG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGxhcmdlIGZpbGVzIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8g5aSn44GN44Gq44OV44Kh44Kk44Or44KS55Sf5oiQXG4gICAgICBjb25zdCBsYXJnZUNvZGUgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAwIH0sIChfLCBpKSA9PiBcbiAgICAgICAgYGZ1bmN0aW9uIGZ1bmMke2l9KCkgeyByZXR1cm4gJHtpfTsgfWBcbiAgICAgICkuam9pbignXFxuJyk7XG4gICAgICBcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHRlc3RQcm9qZWN0UGF0aCwgJ3NyYy9sYXJnZS50cycpLCBsYXJnZUNvZGUpO1xuXG4gICAgICBjb25zdCBpc3N1ZTogSXNzdWUgPSB7XG4gICAgICAgIGlkOiAndGVzdC1pc3N1ZS05JyxcbiAgICAgICAgdHlwZTogJ2xhcmdlLWZpbGUtdGVzdCcsXG4gICAgICAgIHNldmVyaXR5OiAnbWVkaXVtJyxcbiAgICAgICAgbWVzc2FnZTogJ0xhcmdlIGZpbGUgdGVzdCcsXG4gICAgICAgIGxpbmU6IDUwMCxcbiAgICAgICAgZmlsZTogcGF0aC5qb2luKHRlc3RQcm9qZWN0UGF0aCwgJ3NyYy9sYXJnZS50cycpLFxuICAgICAgICBmaWxlUGF0aDogcGF0aC5qb2luKHRlc3RQcm9qZWN0UGF0aCwgJ3NyYy9sYXJnZS50cycpLFxuICAgICAgICBjYXRlZ29yeTogJ3BlcmZvcm1hbmNlJyBhcyBjb25zdFxuICAgICAgfTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBhbmFseXplci5hbmFseXplQ29kZUNvbnRleHQoaXNzdWUsIHRlc3RQcm9qZWN0UGF0aCwge1xuICAgICAgICBhbmFseXplRnVuY3Rpb25zOiB0cnVlLFxuICAgICAgICBjb250ZXh0TGluZXM6IDIwXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICBleHBlY3QoY29udGV4dC5mdW5jdGlvbnMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oOTAwKTtcbiAgICAgIGV4cGVjdChlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0JlTGVzc1RoYW4oMzAwMCk7IC8vIDPnp5Lku6XlhoVcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwidmVyc2lvbiI6M30=