# Rimor v0.8.0 リファクタリング・マスタープラン

## 1. 戦略的背景と目的

### 1.1. Rimorの根幹にある「Why」

ソフトウェア開発において、テストカバレッジのような「量」の指標だけでは、その品質を真に保証することはできない。Rimorプロジェクトの根幹にある目的（Why）は、この課題を解決することにある。

それは、**「テストの『質』を監査し、開発者が自身のテストスイートに真の自信を持てるようにすること」** である。

単にテストの有無をチェックするのではなく、一歩踏み込んだ「質的監査」を提供すること。そして、開発者が「テストをたくさん書いたから大丈夫」という幻想から脱却し、「我々のテストは、確かにこのプロダクトの品質を守っている」と確信できる状態を作ること。それがRimorが提供すべきコアバリューである。

### 1.2. 現状の課題とリファクタリングの必要性

Rimorは、その根幹に強力で価値のある「Why」を持っている。しかし、現状はその価値が、後から付け足された多くの機能と、蓄積された技術的負債の霧の中に埋もれてしまっている状態にある。

- **コンセプトの希薄化**: トレンド分析、高度なセキュリティ解析といった多機能化が、本来の「テスト監査」というシンプルな目的を覆い隠し、ユーザーの混乱を招いている。
- **複雑性による障壁**: 機能の重複や密結合といった内部の技術的な問題が、コアバリューを提供する上での大きな妨げとなっている。
- **信頼性の欠如**: パフォーマンスのボトルネックやビルドの不安定さが、監査ツールとしての信頼性を損なっている。

### 1.3. 戦略的決定：v0.7.0のリリース中止とv0.8.0への統合

上記の課題は、v0.7.0の開発において「CIが通らないためリリース不可能」という形で顕在化した。これは、アーキテクチャの根深い問題が原因である。

この状況を踏まえ、目先の修正に無駄なコストを投下するのではなく、根本解決を目指す「抜本改革アプローチ」を正式に採用する。

1.  **v0.7.0のリリースを公式に中止する。**
2.  v0.7.0で開発された全てのコード（型ベース・セキュリティ監査機能を含む）を、リファクタリングの対象として取り込む。
3.  次にリリースするバージョンは、v0.7.0の機能を含み、かつ本計画書に沿って完全にリファクタリングされた**v0.8.0**とする。

これにより、全ての新機能は、安定したクリーンな技術基盤の上でユーザーに提供される。

---

## 2. 設計思想とアーキテクチャ

### 2.1. 基本方針

本リファクタリングは、以下の2つの方針を両輪として推進する。これは「**何を作るか（What）**」と「**どのように作るか（How）**」を明確に定義する、プロジェクトの基本原則である。

- **プロダクト方針：シンプル化とコアバリューへの回帰**
  - **コア機能への集中**: 「テストの質を監査する」という基本コンセプトに焦点を絞る。
  - **機能の簡素化・分離**: トレンド分析や将来予測といった付随的機能を分離・廃止する。
  - **UI/UXの改善**: CLIコマンドやオプションを整理・統合し、直感的な操作性を提供する。

- **技術方針：疎結合と高いメンテナンス性の実現**
  - **DIコンテナの全面的導入**: `inversify`等を導入し、コンポーネント間の密結合を解消する。
  - **責務の明確化**: 各クラス・モジュールが単一の責務を持つように再設計する。
  - **テスト容易性の最大化**: DIを活用し、純粋な単体テストを徹底できる構造を構築する。

### 2.2. リファクタリング後のコアアーキテクチャ

v0.7.0の先進的なセキュリティ要件を中核に据え、リファクタリング後のRimorの最小構成（ミニマム・コア）を以下のように定義する。

- **入力 (The Gateway): CLIと設定ローダー**
  - **責務**: ユーザーが監査対象とルールを指示する、シンプルで堅牢な入り口。

- **分析 (The Engine): ASTを生成するオーケストレーター**
  - **責務**: ファイルを探索し、AST（抽象構文木）を生成し、それを「監査プラグイン」に渡すことに特化する。
  - **方針**: 従来の3つのアナライザーは、この単一エンジンに統合・置換される。

- **監査 (The Brain): ハイブリッド監査プラグイン群**
  - **責務**: `PluginManager`を通じて、ASTを受け取り、テストの質を多角的に監査する。
  - **構成**: ①`testExistence`等の軽量な「基本監査プラグイン」と、②v0.7.0の`TypeBasedSecurityAnalyzer`を中核とする高度な「静的解析プラグイン」の2本柱で構成する。

- **出力 (The Voice): 深い洞察を与える統合レポート**
  - **責務**: 全ての監査結果を統合し、開発者が行動可能な情報へと変換して出力する。
  - **方針**: 特にセキュリティ問題については、「汚染源(Source)」「経路(Path)」「到達点(Sink)」といったリッチな情報を提供する。

### 2.3. アーキテクチャの全体像

このリファクタリングが目指すのは、**「DIコンテナを土台とし、`AnalysisEngine`がオーケストレーターとしてASTを生成。そのASTを、基本プラグインと高度な静的解析プラグインの両方に提供し、結果を統合レポートとして出力するシステム」**である。このアーキテクチャは、v0.7.0の先進的な機能をクリーンに統合し、将来の拡張性も確保する。

---

## 3. 実行計画

### 3.1. リファクタリングのスコープ

#### 対象範囲（In Scope）
- DIコンテナ（`inversify`）の導入と、主要コンポーネントのDIコンテナへの登録
- `Analyzer`, `ParallelAnalyzer`, `CachedAnalyzer`の機能を、単一の`AnalysisEngine`への統合
- `PluginManager`の再設計（レガシープラグインのサポート廃止とサンドボックス管理の内部化）
- 分散したセキュリティ検証ロジック（`CLISecurity`等）を単一の`SecurityValidationService`への集約
- スコアリングロジックの簡素化と、`AIOutputCommand`からのロジック分離
- 各CLIコマンドがコアサービスを直接初期化するのではなく、DIコンテナから注入される形への変更
- 上記に伴う、テストコードの全面的な書き換え

#### 対象外（Out of Scope）
- リファクタリング期間中の新規機能の追加
- ユーザーインターフェース（CLIの出力フォーマット等）の大幅な変更（ただし、コマンドやオプションの整理は含む）
- サードパーティライブラリのメジャーバージョンアップ（ただし、`inversify`の導入は除く）

### 3.2. 段階的実行計画

リスクを最小化し、着実に進捗を出すため、以下のフェーズに分けてリファクタリングを実行する。

- **フェーズ1：基盤構築とスコープ確定**
    - v0.7.0のブランチを開発のベースラインとして統合する。
    - `inversify`, `reflect-metadata`のインストールと`tsconfig.json`の設定更新。
    - DIコンテナの初期設定と、基本的なサービス（ロガー等）の登録。
    - **成果物**: 簡素化・廃止する機能の公式リストを作成し、チームで合意する。

- **フェーズ2：コアコンポーネントの再構築**
    - `AnalysisEngine`, `PluginManager`, `ConfigLoader`, `SecurityValidator`等のコアサービスを、DIベースの新しいアーキテクチャで再実装する。
    - 新しいインターフェースに対応した単体テストを作成する。

- **フェーズ3：CLIコマンドの統合**
    - 各CLIコマンド（`analyze`, `ai-output`等）を修正し、コアサービスをDIコンテナから受け取るように変更する。
    - 既存のE2Eテストや結合テストがパスすることを確認する。

- **フェーズ4：クリーンアップと検証**
    - 古い実装（旧アナライザー、直接初期化していたロジック等）を完全に削除する。
    - プロジェクト全体のテストカバレッジを測定し、品質を最終確認する。
    - `npm run build`, `npm run lint`, `npm run test` が全て成功することを確認する。

### 3.3. リスクと対策

- **リスク**: リファクタリングが長期化し、通常の開発が停滞する。
    - **対策**: 上記の段階的実行計画に従い、マイルストーンを明確にして進める。スコープ外の作業を厳密に管理する。
- **リスク**: 既存の振る舞いを破壊するデグレード（機能低下）が発生する。
    - **対策**: 既存のテストスイートを最大限活用し、リファクタリングの各段階で回帰テストを徹底する。CIによる自動検証を必須とする。
- **リスク**: 機能削除に対する既存ユーザーからの反発。
    - **対策**: ユーザーは開発者自身のみであるため、このリスクは存在しない。

### 3.4. 期待される効果

- **開発者体験の向上**: 疎結合でテストしやすいコードは、開発者の生産性と満足度を向上させる。
- **ユーザー体験の向上**: シンプルで分かりやすいプロダクトは、ユーザーの混乱をなくし、本来の価値を明確に伝える。
- **品質の向上**: テスト容易性の向上は、より堅牢でバグの少ないプロダクトにつながる。
- **市場投入速度の向上**: 変更容易性の向上により、将来の機能追加や改善を迅速に行えるようになる。

---

## Appendix A: v0.7.0 機能の現状分析

リファクタリングに着手するにあたり、統合対象であるv0.7.0のセキュリティ機能の現状を正確に把握することが不可欠である。以下にその調査結果を記述する。

### A.1. 総評：野心的な設計と、未完の実装のギャップ

v0.7.0のセキュリティ機能は、要件定義書に示された通り、TaintTyperの論文に基づく**極めて先進的で野心的な設計**がなされている。型システム、格子理論、フロー解析、モジュラー解析といったコンセプトは、コードの至る所に反映されており、その理論的基盤の確かさが伺える。

しかし、その一方で、**実装はコンセプトに追いついておらず、多くの部分が未完成または簡易実装（スタブ）のまま**である。特に、各コンポーネント間の連携が不十分であり、これがCIの失敗や、機能全体の不安定さの根本原因であると強く推測される。

設計思想は「100点」だが、実装の完成度は「40点」というのが客観的な評価である。

### A.2. 主要要件別の実装状況評価

| 要件カテゴリ | 要件 | 実装状況 | 評価・コメント |
| :--- | :--- | :--- | :--- |
| **型システム** | ブランド型、`TaintLevel` Enum、`SecurityLattice`クラス | ✅ **実装済み** | `security/types`配下に、要件定義書通りの型定義やEnum、格子演算クラスが実装されている。これは、プロジェクトの理論的基盤がしっかり固まっていることを示している。 |
| **モジュラー解析** | `ModularTestAnalyzer`クラス、インクリメンタル解析のインターフェース | ⚠️ **部分的** | `ModularTestAnalyzer`クラスは存在するが、その中身は**ほぼ空**である。キャッシュ機構は`Map`を使った簡易的なもので、依存関係の伝播（`propagateChanges`）も未実装。コンセプトは存在するが、最も重要な解析ロジックが欠落している。 |
| **モジュラー解析** | メソッドシグネチャベースの要件推論 | ⚠️ **部分的** | `SignatureBasedInference`クラスは存在するが、非常に単純な文字列マッチングに留まっている。パラメータの型やアノテーションを考慮した、要件定義書レベルの高度な推論は実装されていない。 |
| **フロー解析** | `FlowSensitiveAnalyzer`クラス、データフロー追跡 | ⚠️ **部分的** | `FlowSensitiveAnalyzer`クラスは存在するが、**最も重要なデータフローグラフの構築とパス解析が簡易実装**であり、変数間の依存関係を正確に追跡できていない。これでは、汚染が実際にどう伝播したかを検証できない。 |
| **フロー解析** | 汚染伝播解析 | ❌ **未実装** | `TaintPropagationAnalyzer`クラスは要件定義書に存在するが、**コードベースには存在しない**。フロー解析が不完全なため、その結果を利用する汚染伝播の具体的な解析ロジックも実装されていない。 |
| **コンパイル時解析** | `TypeBasedSecurityEngine`クラス、TypeScript Compiler APIとの連携 | ✅ **実装済み** | `TypeBasedSecurityEngine`は、この機能群のトップレベルの統合エンジンとして実装されている。コンパイラAPIと連携しようという意図は明確だが、各解析器が未完成なため、エンジン全体としては機能していない。 |
| **プラグイン** | `ITypeBasedSecurityPlugin`インターフェース、`TypedAuthTestQualityPlugin` | ✅ **実装済み** | `TypedAuthTestQualityPlugin`と`InputValidationSecurityPlugin`が作成されており、リファクタリング後のプラグインアーキテクチャの良い雛形となる。ただし、内部の解析ロジックは他の未完成コンポーネントに依存しているため、不完全である。 |
| **AI向け情報提供** | `TypeAwareProgressiveAI`クラス | ⚠️ **部分的** | クラスとインターフェースは定義されているが、内部のロジックは**ほぼ全てがモック（簡易的なダミーデータ）**を返す実装になっている。コンセプトは存在するが、実際の解析結果を構造化して提供する部分は未実装。 |
| **実装アーキテクチャ** | `TypeBasedSecurityAnalyzer`クラス、並列処理 | ⚠️ **部分的** | `TypeBasedSecurityEngine`が`TypeBasedSecurityAnalyzer`の役割を担っている。`WorkerPool`というクラスは存在するが、これも中身のないスタブであり、**実際の並列処理（`worker_threads`など）は実装されていない**。 |

### A.3. CIが失敗する原因についての考察

CIが失敗する原因は、特定のバグというよりも、**未完成なコンポーネント同士を無理に結合しようとした結果、発生している構造的な問題**である可能性が高い。

- **不完全なデータフロー**: フロー解析が不完全なため、後続の汚染解析や要件検証が、期待通りのデータ構造を受け取れず、null参照エラーや型エラーを引き起こしている。
- **スタブ実装への依存**: モックデータを返すことを前提としたコンポーネントと、実際のデータを処理しようとするコンポーネントが混在し、データの不整合が発生している。
- **複雑なクラス間の依存**: `TypeBasedSecurityEngine`が、未完成な各解析器を直接インスタンス化して呼び出しており、どこか一つが不完全なデータを返すと、連鎖的にエラーが発生する構造になっている。

### A.4. 結論とリファクタリングへの示唆

v0.7.0のセキュリティ機能は、**「設計図は素晴らしいが、建物はまだ基礎工事と骨組みの段階」**と言える。この状態でCIを通すために場当たり的な修正を試みるのは、無駄なコストを発生させるだけであり、賢明ではない。

**v0.8.0のリファクタリングでは、この優れた設計図（要件定義書）を元に、未完成な部分を着実に実装し、DIコンテナを使って疎結合に組み上げていく**ことが、最も合理的かつ確実な道筋である。
